import{_ as n,W as r,X as s,Y as t,Z as e,$ as o,a1 as a,C as i}from"./framework-17a5d3b6.js";const l={},p={id:"操作系统中的缺页中断",tabindex:"-1"},c=t("a",{class:"header-anchor",href:"#操作系统中的缺页中断","aria-hidden":"true"},"#",-1),h=a('<p><strong>缺页</strong>：内存管理时系统采用的是虚拟内存，虚拟内存并不能与实际内存建立完全的映射关系。缺页就是虚拟内存无法与实际内存建立映射的一种情况。</p><p><strong>中断</strong>：中断是指计算机在执行程序的过程中，当出现异常情况或特殊请求时，计算机停止现行程序的运行，转向对这些异常情况或特殊请求的处理，处理结束后再返回现行程序的间断处，继续执行原程序。</p><p>缺页中断就是要访问的页不在主存，需要操作系统将其调入主存后再进行访问。当访问已映射在虚拟地址空间中，但是并未被加载在物理内存中的一个分页时，由CPU的MMU所发出的中断。通常情况下，用于处理此中断的程序是操作系统的一部分。如果操作系统判断此次访问是有效的，那么操作系统会尝试将相关的分页从硬盘上的虚拟内存文件中调入内存。而如果访问是不被允许的，那么操作系统通常会结束相关的进程。</p><div class="hint-container tip"><p class="hint-container-title">补充</p><p><strong>缺页中断发生时的事件顺序</strong>：</p><p>硬件陷入内核，在堆栈中保存程序计数器，将当前指令的各种状态信息保存在特殊的 CPU 寄存器中；保存通用寄存器和其他易失的信息，以免被操作系统破坏；当操作系统发现一个缺页中断时，尝试发现需要哪个虚拟页面。通常一个硬件寄存器包含了这一信息，如果没有的话，操作系统必须检索程序计数器，取出这条指令，用软件分析这条指令，看看它在缺页中断时正在做什么；</p><p>一旦知道了发生缺页中断的虚拟地址，操作系统检查这个地址是否有效，并检查存取与保护是否一致。如果不一致，向进程发出一个信号或杀掉该进程。如果地址有效且没有保护错误发生，系统则检查是否有空闲页框。如果没有空闲页框，执行页面置换算法寻找一个页面来淘汰；</p><p>如果选择的页框“脏”了，安排该页写回磁盘，并发生一次上下文切换，挂起产生缺页中断的进程，让其他进程运行直至磁盘传输结束。无论如何，该页框被标记为忙，以免因为其他原因而被其他进程占用；</p><p>一旦页框“干净”后，操作系统查找所需页面在磁盘上的地址，通过磁盘操作将其装入。该页面被装入后，产生缺页中断的进程仍然被挂起，并且如果有其他可运行的用户进程，则选择另一个用户进程运行；</p><p>当磁盘中断发生时，表明该页已经被装入，页表已经更新可以反映它的位置，页框也被标记为正常状态；</p><p>恢复发生缺页中断指令以前的状态，程序计数器重新指向这条指令；</p><p>调度引发缺页中断的进程，操作系统返回调用它的汇编语言程序；</p><p>该程序恢复寄存器和其他状态信息，返回到用户空间继续执行。</p></div>',4),_={id:"操作系统如何进行内存管理",tabindex:"-1"},g=t("a",{class:"header-anchor",href:"#操作系统如何进行内存管理","aria-hidden":"true"},"#",-1),u=t("p",null,"操作系统内存管理包含了物理内存管理和虚拟内存管理。",-1),m=t("p",null,"物理内存管理包含：交换技术、连续分配管理和非连续分配管理。",-1),P=t("p",null,"虚拟内存管理包含：虚拟内存概念、请求分页管理、页面置换算法。",-1),I={id:"什么时候会由用户态陷入内核态",tabindex:"-1"},b=t("a",{class:"header-anchor",href:"#什么时候会由用户态陷入内核态","aria-hidden":"true"},"#",-1),x=t("ul",null,[t("li",null,[t("strong",null,"发生系统调用时"),e("：这是处于用户态的进程主动请求切换到内核态的一种方式。用户态的进程通过系统调用申请使用操作系统提供的系统调用服务例程来处理任务。而系统调用的机制，其核心是使用软中断。")]),t("li",null,[t("strong",null,"产生异常时"),e("：当CPU执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行的进程切换到处理此异常的内核相关的程序中，也就是转到了内核态，如缺页异常。")]),t("li",null,[t("strong",null,"外部设备产生中断时"),e("：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作的完成。")])],-1),R={id:"操作系统中-虚拟地址与物理地址之间如何映射",tabindex:"-1"},f=t("a",{class:"header-anchor",href:"#操作系统中-虚拟地址与物理地址之间如何映射","aria-hidden":"true"},"#",-1),F=t("p",null,"虚拟内存地址由页号和偏移量组成。虚拟地址到物理地址的映射以页为单位，通过页表把虚拟地址所在的虚拟页映射到一个物理页，然后再在这个物理页上根据页内偏移找到物理地址，从而完成映射。",-1),y={id:"操作系统中malloc的实现原理",tabindex:"-1"},N=t("a",{class:"header-anchor",href:"#操作系统中malloc的实现原理","aria-hidden":"true"},"#",-1),S=t("p",null,"malloc 函数的实质是它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表。 调用 malloc()函数时，它沿着连接表寻找一个大到足以满足用户请求所需要的内存块。(如果没有搜索到，那么就会用sbrk()才推进brk指针来申请内存空间)。 然后，将该内存块一分为二(一块的大小与用户申请的大小相等，另一块的大小就是剩下来的字节)。 接下来，将分配给用户的那块内存存储区域传给用户，并将剩下的那块(如果有的话)返回到连接表上。 调用 free 函数时，它将用户释放的内存块连接到空闲链表上。",-1),V={id:"malloc创建的对象在堆还是栈中",tabindex:"-1"},L=t("a",{class:"header-anchor",href:"#malloc创建的对象在堆还是栈中","aria-hidden":"true"},"#",-1),M=t("p",null,"malloc 函数的实质是它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表。",-1),Z=t("p",null,"调用 malloc()函数时，它沿着连接表寻找一个大到足以满足用户请求所需要的内存块，如果没有搜索到，那么就会用sbrk()才推进brk指针来申请内存空间。 然后，将该内存块一分为二(一块的大小与用户申请的大小相等，另一块的大小就是剩下来的字节)。 接下来，将分配给用户的那块内存存储区域传给用户，并将剩下的那块(如果有的话)返回到连接表上。调用 free 函数时，它将用户释放的内存块连接到空闲链表上。",-1),G={id:"lvs的nat、tun、dr原理及区别",tabindex:"-1"},z=t("a",{class:"header-anchor",href:"#lvs的nat、tun、dr原理及区别","aria-hidden":"true"},"#",-1),T=a('<p>LVS是Linux Virtual Server的简写，意即Linux虚拟服务器，是一个虚拟的服务器集群系统,使用负载均衡技术将多台服务器组成一个虚拟服务器。虚拟服务器的体系结构由一组服务器通过高速的局域网或者地理分布的广域网相互连接，在它们的前端有一个负载调度器(Load Balancer)。负载调度器能无缝地将网络请求调度到真实服务器上。 <img src="https://img-blog.csdnimg.cn/20210709211936454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgwODQ4Mw==,size_16,color_FFFFFF,t_70" alt="" loading="lazy"></p><ul><li><p><strong>NAT(网络地址转换模式)</strong></p><p>原理：就是把客户端发来的数据包的IP头的目的地址，在负载均衡器上换成其中一台RS的IP地址，并发至此RS来处理,RS处理完成后把数据交给经过负载均衡器,负载均衡器再把数据包的原IP地址改为自己的IP，将目的地址改为客户端IP地址即可。</p><figure><img src="https://img-blog.csdnimg.cn/20201124093420164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDY2MzIwMg==,size_16,color_FFFFFF,t_70#pic_center" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></li><li><p><strong>TUN(IP隧道模式)</strong></p><p>原理：隧道模式就是，把客户端发来的数据包，封装一个新的IP头标记(仅目的IP)发给RS,RS收到后,先把数据包的头解开,还原数据包,处理后,直接返回给客户端,不需要再经过负载均衡器。注意,由于RS需要对负载均衡器发过来的数据包进行还原,所以说必须支持IPTUNNEL协议，所以,在RS的内核中,必须编译支持IPTUNNEL这个选项。</p><p>各集群节点可以跨越不同的网络，不用在同一个VLAN。</p><p>调度器根据各个服务器的负载情况,动态地选择一台服务器,将请求报文封装在另一个 IP 报文中,再将封装后的 IP 报文转发给选出的服务器</p><p>服务器收到报文后,先将报文解封获得原来目标地址为 VIP 的报文,服务器发现 VIP地址被配置在本地的 IP 隧道设备上,所以就处理这个请求,然后根据路由表将响应报文直接返回给客户.</p><figure><img src="https://img-blog.csdnimg.cn/20201124093401589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDY2MzIwMg==,size_16,color_FFFFFF,t_70#pic_center" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></li><li><p><strong>DR(直接路由模式)</strong></p><p>原理：负载均衡器和RS都使用同一个IP对外服务，但只有DR对ARP请求进行响应,所有RS对本身这个IP的ARP请求保持静默，也就是说,网关会把对这个服务IP的请求全部定向给DR,而DR收到数据包后根据调度算法,找出对应的RS,把目的MAC地址改为RS的MAC(因为IP一致)并将请求分发给这台RS，这时RS收到这个数据包,处理完成之后，由于IP一致，可以直接将数据返给客户，则等于直接从客户端收到这个数据包无异,处理后直接返回给客户端。由于负载均衡器要对二层包头进行改换,所以负载均衡器和RS之间必须在一个广播域,也可以简单的理解为在同一台交换机上。</p><figure><img src="https://img-blog.csdnimg.cn/20201124093342117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDY2MzIwMg==,size_16,color_FFFFFF,t_70#pic_center" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></li></ul><p><strong>区别：</strong></p><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>NAT</td><td>集群中的物理服务器可以使用任何支持TCP/IP操作系统它只需要一个 IP 地址配置在调度器上，服务器组可以用私有的 IP 地址</td><td>扩展性有限。当服务器节点(普通PC服务器)增长过多时,负载均衡器将成为整个系统的瓶颈，因为所有的请求包和应答包的流向都经过负载均衡器。当服务器节点过多时，大量的数据包都交汇在负载均衡器那，速度就会变慢。</td></tr><tr><td>TUN</td><td>负载均衡器只负责将请求包分发给后端节点服务器，而RS将应答包直接发给用户。所以，减少了负载均衡器的大量数据流动，负载均衡器不再是系统的瓶颈，就能处理很巨大的请求量，这种方式，一台负载均衡器能够为很多RS进行分发。而且跑在公网上就能进行不同地域的分发。</td><td>隧道模式的RS节点需要合法IP，这种方式需要所有的服务器支持”IP Tunneling”(IP Encapsulation)协议，服务器可能只局限在部分Linux系统上。</td></tr><tr><td>DR</td><td>VS/DR跟 VS/TUN 方法相同，负载调度器中只负责调度请求，而服务器直接将响应返回给客户，可以极大地提高整个集群系统的吞吐量。</td><td>要求负载均衡器的网卡必须与物理网卡在一个物理段上</td></tr></tbody></table><table><thead><tr><th></th><th>NAT模式</th><th>IP TUN模式</th><th>DR模式</th></tr></thead><tbody><tr><td>对服务器要求</td><td>任何操作系统均支持</td><td>必须支持IP隧道协议，目前只有Linux支持</td><td>支持虚拟网卡，且可以禁用ARP响应</td></tr><tr><td>网络要求</td><td>局域网</td><td>局域网或广域网</td><td>局域网</td></tr><tr><td>支持的节点数</td><td>10~20个，视Director处理能力而定</td><td>可以支持到100个节点</td><td>可以支持到100个节点</td></tr><tr><td>安全性</td><td>较高，可隐藏real server</td><td>较差，real server 容易暴露</td><td>较差，real server 容易暴露</td></tr><tr><td>IP要求</td><td>仅需要一个合法IP地址作为VIP</td><td>除VIP外，每个服务器需要拥有合法IP地址可以直接路由至客户端</td><td>除VIP外，每个服务器需要拥有合法IP地址可以直接路由至客户端</td></tr><tr><td>拓展性</td><td>差</td><td>很好</td><td>好</td></tr><tr><td>特点</td><td>地址转换</td><td>封装IP</td><td>修改MAC地址</td></tr></tbody></table>',5);function k(w,D){const d=i("Badge");return r(),s("div",null,[t("h3",p,[c,e(" 操作系统中的缺页中断？"),o(d,{text:"掌握",type:"tip"})]),h,t("h3",_,[g,e(" 操作系统如何进行内存管理？"),o(d,{text:"了解",type:"info"})]),u,m,P,t("h3",I,[b,e(" 什么时候会由用户态陷入内核态？"),o(d,{text:"掌握",type:"tip"})]),x,t("h3",R,[f,e(" 操作系统中，虚拟地址与物理地址之间如何映射？"),o(d,{text:"掌握",type:"tip"})]),F,t("h3",y,[N,e(" 操作系统中malloc的实现原理？"),o(d,{text:"掌握",type:"tip"})]),S,t("h3",V,[L,e(" malloc创建的对象在堆还是栈中？"),o(d,{text:"了解",type:"info"})]),M,Z,t("h3",G,[z,e(" LVS的NAT、TUN、DR原理及区别？"),o(d,{text:"了解",type:"info"})]),T])}const C=n(l,[["render",k],["__file","other.html.vue"]]);export{C as default};
