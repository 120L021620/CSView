const e=JSON.parse('{"key":"v-3216abfa","path":"/rabbitmq/apply.html","title":"","lang":"zh-CN","frontmatter":{"description":"如何确保消息正确地发送至RabbitMQ？如何确保消息接收方消费了消息？\\r消息确认机制：生产者在发送消息后，可以通过消息确认机制（Confirm）确保消息被正确地发送至 RabbitMQ。消息确认机制分为批量确认和单个确认两种方式，生产者可以选择适合自己业务场景的确认方式。; \\r消息持久化：通过将消息设置为持久化的方式，可以确保消息在发送至 Rabbi...","head":[["meta",{"property":"og:url","content":"https://www.csview.cn/rabbitmq/apply.html"}],["meta",{"property":"og:site_name","content":"CSView计算机招聘知识分享"}],["meta",{"property":"og:description","content":"如何确保消息正确地发送至RabbitMQ？如何确保消息接收方消费了消息？\\r消息确认机制：生产者在发送消息后，可以通过消息确认机制（Confirm）确保消息被正确地发送至 RabbitMQ。消息确认机制分为批量确认和单个确认两种方式，生产者可以选择适合自己业务场景的确认方式。; \\r消息持久化：通过将消息设置为持久化的方式，可以确保消息在发送至 Rabbi..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-02-26T14:02:01.000Z"}],["meta",{"property":"article:modified_time","content":"2023-02-26T14:02:01.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-02-26T14:02:01.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":3,"title":"如何确保消息正确地发送至RabbitMQ？如何确保消息接收方消费了消息？","slug":"如何确保消息正确地发送至rabbitmq-如何确保消息接收方消费了消息","link":"#如何确保消息正确地发送至rabbitmq-如何确保消息接收方消费了消息","children":[]},{"level":3,"title":"如何避免消息重复投递或重复消费？","slug":"如何避免消息重复投递或重复消费","link":"#如何避免消息重复投递或重复消费","children":[]},{"level":3,"title":"如何保证消息持久化？","slug":"如何保证消息持久化","link":"#如何保证消息持久化","children":[]},{"level":3,"title":"消息如何路由？","slug":"消息如何路由","link":"#消息如何路由","children":[]},{"level":3,"title":"RabbitMQ的消息确认过程？","slug":"rabbitmq的消息确认过程","link":"#rabbitmq的消息确认过程","children":[]},{"level":3,"title":"消息基于什么传输？","slug":"消息基于什么传输","link":"#消息基于什么传输","children":[]},{"level":3,"title":"为什么不应该对所有的 message 都使用持久化机制？","slug":"为什么不应该对所有的-message-都使用持久化机制","link":"#为什么不应该对所有的-message-都使用持久化机制","children":[]},{"level":3,"title":"如何保证高可用的？RabbitMQ 的集群？","slug":"如何保证高可用的-rabbitmq-的集群","link":"#如何保证高可用的-rabbitmq-的集群","children":[]},{"level":3,"title":"RabbitMQ上的一个queue中存放的message是否有数量限制？","slug":"rabbitmq上的一个queue中存放的message是否有数量限制","link":"#rabbitmq上的一个queue中存放的message是否有数量限制","children":[]},{"level":3,"title":"在单node系统和多node构成的cluster系统中声明queue, exchange ,以及进行binding会有什么不同？","slug":"在单node系统和多node构成的cluster系统中声明queue-exchange-以及进行binding会有什么不同","link":"#在单node系统和多node构成的cluster系统中声明queue-exchange-以及进行binding会有什么不同","children":[]},{"level":3,"title":"客户端连接到duster中的任意node上是否都能正常工作？","slug":"客户端连接到duster中的任意node上是否都能正常工作","link":"#客户端连接到duster中的任意node上是否都能正常工作","children":[]},{"level":3,"title":"若cluster中拥有某个queue的owner node失效了，且该queue 被声明具有durable属性，是否能够成功从其他node上重新声明该queue ?","slug":"若cluster中拥有某个queue的owner-node失效了-且该queue-被声明具有durable属性-是否能够成功从其他node上重新声明该queue","link":"#若cluster中拥有某个queue的owner-node失效了-且该queue-被声明具有durable属性-是否能够成功从其他node上重新声明该queue","children":[]},{"level":3,"title":"cluster中node的失效会对consumer产生什么影响？若是在cluster中创建了 mirrored queue ，这时node失效会对consumer产生什么影响？","slug":"cluster中node的失效会对consumer产生什么影响-若是在cluster中创建了-mirrored-queue-这时node失效会对consumer产生什么影响","link":"#cluster中node的失效会对consumer产生什么影响-若是在cluster中创建了-mirrored-queue-这时node失效会对consumer产生什么影响","children":[]},{"level":3,"title":"能够在地理上分开的不同数据中心使用RabbitMQ cluster吗？","slug":"能够在地理上分开的不同数据中心使用rabbitmq-cluster吗","link":"#能够在地理上分开的不同数据中心使用rabbitmq-cluster吗","children":[]},{"level":3,"title":"为什么heavy RPC的使用场景下不建议采用disk node ?","slug":"为什么heavy-rpc的使用场景下不建议采用disk-node","link":"#为什么heavy-rpc的使用场景下不建议采用disk-node","children":[]},{"level":3,"title":"向不存在的exchange发publish消息会发生什么？向不存在的queue执行consume动作会发生什么？","slug":"向不存在的exchange发publish消息会发生什么-向不存在的queue执行consume动作会发生什么","link":"#向不存在的exchange发publish消息会发生什么-向不存在的queue执行consume动作会发生什么","children":[]},{"level":3,"title":"为什么说保证message被可靠持久化的条件是queue和 exchange具有durable属性，同时message具有 persistent属性才行？","slug":"为什么说保证message被可靠持久化的条件是queue和-exchange具有durable属性-同时message具有-persistent属性才行","link":"#为什么说保证message被可靠持久化的条件是queue和-exchange具有durable属性-同时message具有-persistent属性才行","children":[]},{"level":3,"title":"Consumer Cancellation Notification 机制用于什么场景？","slug":"consumer-cancellation-notification-机制用于什么场景","link":"#consumer-cancellation-notification-机制用于什么场景","children":[]},{"level":3,"title":"Basic.Reject的用法是什么？","slug":"basic-reject的用法是什么","link":"#basic-reject的用法是什么","children":[]},{"level":3,"title":"死信队列和延迟队列的使用？","slug":"死信队列和延迟队列的使用","link":"#死信队列和延迟队列的使用","children":[]},{"level":3,"title":"什么情况下producer不主动创建queue是安全的？","slug":"什么情况下producer不主动创建queue是安全的","link":"#什么情况下producer不主动创建queue是安全的","children":[]},{"level":3,"title":"如何保证消息的顺序性？","slug":"如何保证消息的顺序性","link":"#如何保证消息的顺序性","children":[]},{"level":3,"title":"无法被路由的消息去了哪里？","slug":"无法被路由的消息去了哪里","link":"#无法被路由的消息去了哪里","children":[]},{"level":3,"title":"消息什么时候会变成死信？","slug":"消息什么时候会变成死信","link":"#消息什么时候会变成死信","children":[]},{"level":3,"title":"RabbitMQ事务机制？","slug":"rabbitmq事务机制","link":"#rabbitmq事务机制","children":[]}],"git":{"createdTime":1677035158000,"updatedTime":1677420121000,"contributors":[{"name":"zijing2333","email":"qq944741457@gmail.com","commits":2}]},"readingTime":{"minutes":16.53,"words":4959},"filePathRelative":"rabbitmq/apply.md","localizedDate":"2023年2月22日","autoDesc":true,"excerpt":""}');export{e as data};
