import{_ as c,X as i,Y as l,Z as n,$ as s,a0 as a,a2 as t,H as p}from"./framework-edbf9e3c.js";const u={},r={id:"make和new区别",tabindex:"-1"},d=n("a",{class:"header-anchor",href:"#make和new区别","aria-hidden":"true"},"#",-1),k=n("p",null,[n("strong",null,"make"),s("：make能够"),n("strong",null,"分配并初始化"),s("类型所需的内存空间和结构，返回引用类型的本身；make具有使用范围的局限性，仅支持 channel、map、slice三种类型；make函数会对三种类型的内部数据结构（长度、容量等）赋值。")],-1),v=n("p",null,[n("strong",null,"new"),s("：new能够"),n("strong",null,"分配"),s("类型所需的内存空间，返回指针引用（指向内存的指针）；new可被替代，能够通过字面值快速初始化。")],-1),m={id:"slice的底层实现",tabindex:"-1"},b=n("a",{class:"header-anchor",href:"#slice的底层实现","aria-hidden":"true"},"#",-1),h=t(`<p>切片的底层是一个结构体，对应三个参数，一个是<strong>unsafe.Pointer指针</strong>，指向一个具体的底层数组，一个是<strong>cap</strong>，切片的容量，一个是<strong>len</strong>，切片的长度。</p><p>因为切片是基于数组实现，所以它的底层的内存是连续分配的，效率非常高，可以通过索引获得数据。切片本身并不是动态数组或者数组指针，而是设定相关属性，将数据读写操作限定在指定的区域内。切片本身是一个只读对象，其工作机制类似数组指针的一种封装。</p><p>如果make函数初始化了一个太大的切片，该切片就会逃逸到堆区；如果分配了一个比较小的切片，就会被分配到栈区，切片大小的临界值默认为64KB，因此make([]int64, 1023) 和 make([]int64, 1024) 是完全不同的内存布局。</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> slice <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	array unsafe<span class="token punctuation">.</span>Pointer
	<span class="token builtin">len</span>   <span class="token builtin">int</span>
	<span class="token builtin">cap</span>   <span class="token builtin">int</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,4),g={id:"slice和数组的区别",tabindex:"-1"},f=n("a",{class:"header-anchor",href:"#slice和数组的区别","aria-hidden":"true"},"#",-1),_=n("p",null,[n("strong",null,"切片是指针类型，数组是值类型")],-1),y=n("p",null,"传递数组是通过拷贝的方式，传递切片是通过传递引用的方式。",-1),w=n("p",null,[n("strong",null,"数组的长度固定，而切片可以进行动态扩容")],-1),x=n("p",null,"数组是一组内存空间连续的数据，一旦初始化长度大小就不会再改变，切片的长度可以进行扩展，当切片底层的数组容量不够时，切片会创建新的底层数组。",-1),q=n("p",null,[n("strong",null,"切片比数组多一个属性容量（cap)")],-1),P={id:"slice的扩容机制",tabindex:"-1"},z=n("a",{class:"header-anchor",href:"#slice的扩容机制","aria-hidden":"true"},"#",-1),S=t('<p>扩容主要分为两个过程：第一步是分配新的内存空间，第二步是将原有切片内容进行复制。分配新空间时候需要估计大致容量，然后再确定容量。</p><p>根据该切片当前容量选择不同的策略：</p><ul><li>如果期望容量大于当前容量的两倍，就会使用期望容量</li><li>如果当前切片的长度小于 1024，容量就会翻倍</li><li>如果当前切片的长达大于 1024，每次扩容 25% 的容量，直到新容量大于期望容量</li><li>在进行循环1.25倍计算时，最终容量计算值发生溢出，即超过了int的最大范围，则最终容量就是新申请的容量</li></ul><p>对于切片的扩容</p><ul><li>当切片比较小的，采用较大的扩容倍速进行扩容，避免频繁扩容，从而减少内存分配的次数和数据拷贝的代价</li><li>当切片较大的时，采用较小的扩容倍速，主要避免空间浪费</li></ul><h3 id="slice是线程安全的吗" tabindex="-1"><a class="header-anchor" href="#slice是线程安全的吗" aria-hidden="true">#</a> slice是线程安全的吗？</h3><p>不是。slice底层结构并没有使用加锁等方式，不支持并发读写，所以并不是线程安全的，使用多个goroutine对类型为slice的变量进行操作，每次输出的值大概率都不会一样，与预期值不一致; slice在并发执行中不会报错，但是数据会丢失。</p><p><strong>实现线程安全的方法</strong>：</p><p>互斥锁，读写锁，原子操作，sync.once，sync.atomic，channel。</p>',9),A={id:"map的底层数据结构",tabindex:"-1"},W=n("a",{class:"header-anchor",href:"#map的底层数据结构","aria-hidden":"true"},"#",-1),B=t(`<p><strong>结构</strong>：底层是由hmap和bmap两个结构体实现，map在实际存储键值对结构用到了数组和链表。之所以高效，是因为其结合了顺序存储数组和链式存储(链表)两种存储结构。数组是map的主干，在数组下有一个类型为链表的元素。</p><p><strong>hmap</strong>：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> hmap <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    count     <span class="token builtin">int</span>    <span class="token comment">//元素的个数</span>
    flags     <span class="token builtin">uint8</span>  <span class="token comment">//状态标志</span>
    B         <span class="token builtin">uint8</span>  <span class="token comment">//可以最多容纳 6.5 * 2 ^ B 个元素，6.5为装载因子</span>
    noverflow <span class="token builtin">uint16</span> <span class="token comment">//溢出的个数</span>
    hash0     <span class="token builtin">uint32</span> <span class="token comment">//哈希种子</span>

    buckets    unsafe<span class="token punctuation">.</span>Pointer <span class="token comment">//指向一个桶数组</span>
    oldbuckets unsafe<span class="token punctuation">.</span>Pointer <span class="token comment">//指向一个旧桶数组，用于扩容</span>
    nevacuate  <span class="token builtin">uintptr</span>        <span class="token comment">//搬迁进度，小于nevacuate的已经搬迁</span>
    overflow <span class="token operator">*</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>bmap     <span class="token comment">//指向溢出桶的指针</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>hmap是map的最外层的一个数据结构，包括了map的各种基础信息、如大小、bucket。buckets这个参数它存储的是指向buckets数组的一个指针。</p><p><strong>bmap</strong>：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> bmap <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token comment">//元素hash值的高8位代表它在桶中的位置，如果tophash[0] &lt; minTopHash，表示这个桶的搬迁状态</span>
    tophash <span class="token punctuation">[</span>bucketCnt<span class="token punctuation">]</span><span class="token builtin">uint8</span>
    <span class="token comment">//接下来是8个key、8个value，但是我们不能直接看到；为了优化对齐，go采用了key放在一起，value放在一起的存储方式，</span>
    keys     <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span>keytype   <span class="token comment">//key单独存储</span>
	values   <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span>valuetype <span class="token comment">//value单独存储</span>
	pad      <span class="token builtin">uintptr</span>
	overflow <span class="token builtin">uintptr</span>	  <span class="token comment">//指向溢出桶的指针</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>bucket(桶)，每一个bucket最多放8个key和value，最后由一个overflow字段指向下一个bmap，key、value、overflow字段都不显示定义，而是通过maptype计算偏移获取的。</p><div class="hint-container tip"><p class="hint-container-title">高位哈希和低位哈希</p><p>哈希函数会将传入的key值进行哈希运算，得到一个唯一的值。前半部分就叫做<strong>高位哈希值</strong>，后半部分就叫做<strong>低位哈希值</strong>。<strong>高位哈希值是用来确定当前的bucket有没有所存储的数据的；低位哈希值是用来确定，当前的数据存在了哪个bucket</strong></p></div>`,8),M={id:"bucket是如何工作的",tabindex:"-1"},G=n("a",{class:"header-anchor",href:"#bucket是如何工作的","aria-hidden":"true"},"#",-1),N=n("p",null,[s("bucket的tophash存储高八位哈希以加快索引。"),n("strong",null,"把高八位存储起来，不用完整比较key就能过滤掉不符合的key，加快查询速度"),s("。当一个哈希值的高8位和存储的高8位相符合，再去比较完整的key值，进而取出value。当超过8个元素需要存入某个bucket时，"),n("code",null,"hmap"),s("会拓展该bucket。")],-1),C=n("p",null,"存储的key 和value底层排列方式是：key全部放在一起，value全部放在一起。当key大于128字节时，bucket的key和value字段存储的是指针，指向实际内容。这样排列好处是在key和value的长度不同的时候，可以消除padding带来的空间浪费",-1),E=n("p",null,"bucket还存储的溢出时指向的下一个bucket的指针。如果超过就重新创建一个bucket挂在原bucket上，持续挂接形成链表。",-1),I={id:"map的查找过程",tabindex:"-1"},L=n("a",{class:"header-anchor",href:"#map的查找过程","aria-hidden":"true"},"#",-1),V=n("p",null,"查找或操作map时，首先key经过hash函数生成hash值，通过哈希值的低8位来判断当前数据属于哪个bucket，找到bucket以后，通过哈希值的高八位与bucket存储的高位哈希值循环比对，如果相同就比较刚才找到的底层数组的key值，如果key相同，取出value。如果高八位hash值在此bucket没有，或者有，但是key不相同，就去链表中下一个溢出bucket中查找，直到查找到链表的末尾。",-1),D={id:"map的扩容过程",tabindex:"-1"},R=n("a",{class:"header-anchor",href:"#map的扩容过程","aria-hidden":"true"},"#",-1),T=t('<p>bmap扩容的加载因数达到6.5(元素个数/bucket)，bmap就会进行扩容，将原来bucket数组数量扩充一倍，产生一个新的bucket数组。这样bmap中的oldbuckets属性指向的就是旧bucket数组。</p><p>map的扩容不会立马全部复制，而是渐进式扩容，即首先开辟2倍的内存空间，创建一个新的bucket数组。只有当访问原来就的bucket数组时，才会将就得bucket拷贝到新的bucket数组，进行渐进式的扩容。当然旧的数据不会删除，而是去掉引用，等待gc回收。</p><div class="hint-container tip"><p class="hint-container-title">负载因子</p><p>加载因数6.5，这个是经过测试才得出的合理的一个阈值。因为，加载因子越小，空间利用率就小，加载因子越大，产生冲突的几率就大。所以6.5是一个平衡的值。</p></div><h3 id="如何实现一个线程安全的map" tabindex="-1"><a class="header-anchor" href="#如何实现一个线程安全的map" aria-hidden="true">#</a> 如何实现一个线程安全的map？</h3><p>三种方式实现：</p><ul><li>加读写锁</li><li>分片加锁</li><li>sync.Map</li></ul><p>加读写锁、分片加锁，这两种方案都比较常用，后者的性能更好，因为它可以降低锁的粒度，提高访问此 map 对象的吞吐。前者并发性能虽然不如后者，但是加锁的方式更加简单。sync.Map 是 Go 1.9 增加的一个线程安全的 map ，虽然是官方标准，但反而是不常用的，原因是 map 要解决的场景很难描述，很多时候程序员在做抉择是否该用它，不过在一些特殊场景会使用 sync.Map：</p><ul><li>场景一：只会增长的缓存系统，一个 key 值写入一次而被读很多次</li><li>场景二：多个 goroutine 为不相交的键读、写和重写键值对</li></ul>',8),j={href:"https://golang.org/pkg/sync/#Map",target:"_blank",rel:"noopener noreferrer"},F=n("p",null,"加读写锁，扩展 map 来实现线程安全，支持并发读写。使用读写锁 RWMutex，是为了读写性能的考虑。对 map 对象的操作，无非就是常见的增删改查和遍历。我们可以将查询和遍历看作读操作，增加、修改和删除看作写操作。",-1),H=n("div",{class:"hint-container tip"},[n("p",{class:"hint-container-title"},"提示"),n("p",null,"大量并发读写的情况下，锁的竞争会很激烈，导致性能降低。如何解决这个问题？"),n("p",null,"尽量减少锁的粒度和锁的持有时间，减少锁的粒度，常用方法就是分片Shard，将一把锁分成几把锁，每个锁控制一个分片。")],-1),K={id:"channel的概念",tabindex:"-1"},O=n("a",{class:"header-anchor",href:"#channel的概念","aria-hidden":"true"},"#",-1),U=n("p",null,[s("channel又称为管道，用于数据传递或数据共享，其本质是一个先进先出的队列，使用goroutine+channel进行数据通讯简单高效，"),n("strong",null,"同时也线程安全"),s("，多个goroutine可同时修改一个channel，不需要加锁。")],-1),X={id:"channel有哪些状态",tabindex:"-1"},Y=n("a",{class:"header-anchor",href:"#channel有哪些状态","aria-hidden":"true"},"#",-1),Z=t("<p><strong>nil</strong>：未初始化的状态，只进行了声明，或者手动赋值为nil。</p><p><strong>active</strong>：正常的channel，可读或者可写。</p><p><strong>closed</strong>：已关闭，channel的值不是nil，<strong>关闭的状态的channel仍然可以读值（取值），但不能写值（会报panic: send on closed channel）</strong>，nil状态的channel是不能close（panic: close of nil channel）的。如果关闭后的 channel 没有数据可读取时，将得到零值，即对应类型的默认值。</p><table><thead><tr><th>操作</th><th>空channel</th><th>已关闭channel</th><th>活跃中的channel</th></tr></thead><tbody><tr><td>close(ch)</td><td>panic</td><td>panic</td><td>成功关闭</td></tr><tr><td>ch&lt;- v</td><td>永远阻塞</td><td>panic</td><td>成功发送或阻塞</td></tr><tr><td>v,ok = &lt;-ch</td><td>永远阻塞</td><td>不阻塞</td><td>成功接收或阻塞</td></tr></tbody></table>",4),$={id:"如何判断channel已经关闭",tabindex:"-1"},J=n("a",{class:"header-anchor",href:"#如何判断channel已经关闭","aria-hidden":"true"},"#",-1),Q=t(`<div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">if</span> v<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch<span class="token punctuation">;</span> <span class="token operator">!</span>ok <span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;channel 已关闭，读取不到数据&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1),nn={id:"channel的底层实现原理",tabindex:"-1"},sn=n("a",{class:"header-anchor",href:"#channel的底层实现原理","aria-hidden":"true"},"#",-1),an=t(`<p>channel有几个重要的字段：</p><ul><li>buf指向一个底层的循环数组，只有设置为有缓存的channel才会有buf</li><li>sendx和recvx分别指向底层循环数组的发送和接收元素位置的索引</li><li>sendq和recvq分别表示发送数据的被阻塞的goroutine和读取数据的goroutine，这两个都是一个双向链表结构</li><li>sendq和recvq 的结构为等待队列类型，sudog是对goroutine的一种封装</li></ul><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> hchan <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    qcount   <span class="token builtin">uint</span>           <span class="token comment">// channel中的元素个数</span>
    dataqsiz <span class="token builtin">uint</span>           <span class="token comment">// channel中循环队列的长度</span>
    buf      unsafe<span class="token punctuation">.</span>Pointer <span class="token comment">// channel缓冲区数据指针</span>
    elemsize <span class="token builtin">uint16</span>            <span class="token comment">// buffer中每个元素的大小</span>
    closed   <span class="token builtin">uint32</span>            <span class="token comment">// channel是否已经关闭，0未关闭</span>
    elemtype <span class="token operator">*</span>_type <span class="token comment">// channel中的元素的类型</span>
    sendx    <span class="token builtin">uint</span>   <span class="token comment">// channel发送操作处理到的位置</span>
    recvx    <span class="token builtin">uint</span>   <span class="token comment">// channel接收操作处理到的位置</span>
    recvq    waitq  <span class="token comment">// 等待接收的sudog（sudog为封装了goroutine和数据的结构）队列由于缓冲区空间不足而阻塞的goroutine列表</span>
    sendq    waitq  <span class="token comment">// 等待发送的sudog队列，由于缓冲区空间不足而阻塞的goroutine列表</span>

    lock mutex   <span class="token comment">// 一个轻量级锁</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,3),en={id:"channel发送数据和接收数据的过程",tabindex:"-1"},tn=n("a",{class:"header-anchor",href:"#channel发送数据和接收数据的过程","aria-hidden":"true"},"#",-1),pn=t("<p><strong>channel发送数据过程：</strong></p><ul><li>检查 recvq 是否为空，如果不为空，则从 recvq 头部取一个 goroutine，将数据发送过去，并唤醒对应的 goroutine</li><li>如果 recvq 为空，则将数据放入到 buffer 中</li><li>如果 buffer 已满，则将要发送的数据和当前 goroutine 打包成 sudog 对象放入到 sendq中。并将当前 goroutine 置为 waiting 状态</li></ul><p><strong>channel接收数据过程：</strong></p><ul><li>检查sendq是否为空，如果不为空，且没有缓冲区，则从sendq头部取一个goroutine，将数据读取出来，并唤醒对应的goroutine，结束读取过程</li><li>如果sendq不为空，且有缓冲区，则说明缓冲区已满，则从缓冲区中首部读出数据，把sendq头部的goroutine数据写入缓冲区尾部，并将goroutine唤醒，结束读取过程</li><li>如果sendq为空，缓冲区有数据，则直接从缓冲区读取数据，结束读取过程</li><li>如果sendq为空，且缓冲区没数据，则只能将当前的goroutine加入到recvq,并进入waiting状态，等待被写goroutine唤醒</li></ul>",4),on={id:"channel是否线程安全的",tabindex:"-1"},cn=n("a",{class:"header-anchor",href:"#channel是否线程安全的","aria-hidden":"true"},"#",-1),ln=n("p",null,"channel是线程安全的。",-1),un=n("p",null,"不同协程通过channel进行通信，本身的使用场景就是多线程，为了保证数据的一致性必须实现线程安全。",-1),rn={id:"channel如何实现线程安全的",tabindex:"-1"},dn=n("a",{class:"header-anchor",href:"#channel如何实现线程安全的","aria-hidden":"true"},"#",-1),kn=n("p",null,"channel的底层实现中， hchan结构体中采用Mutex锁来保证数据读写安全。在对循环数组buf中的数据进行入队和出队操作时，必须先获取互斥锁，才能操作channel数据。",-1),vn={id:"channel的应用场景",tabindex:"-1"},mn=n("a",{class:"header-anchor",href:"#channel的应用场景","aria-hidden":"true"},"#",-1),bn=t(`<p><strong>任务定时</strong></p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">select</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token operator">&lt;-</span>time<span class="token punctuation">.</span><span class="token function">After</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>定时任务</strong></p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">select</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token operator">&lt;-</span> time<span class="token punctuation">.</span><span class="token function">Tick</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>解耦生产者和消费者</strong></p><p>可以将生产者和消费者解耦出来，生产者只需要往channel发送数据，而消费者只管从channel中获取数据。</p><p><strong>控制并发数</strong></p><p>以爬虫为例，比如需要爬取1w条数据，需要并发爬取以提高效率，但并发量又不能过大，可以通过channel来控制并发规模，比如同时支持5个并发任务：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> url <span class="token operator">:=</span> <span class="token keyword">range</span> urls <span class="token punctuation">{</span>
  <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ch <span class="token operator">&lt;-</span> <span class="token number">1</span>
    <span class="token function">worker</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>
    <span class="token operator">&lt;-</span> ch
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,9),hn={id:"defer的概述",tabindex:"-1"},gn=n("a",{class:"header-anchor",href:"#defer的概述","aria-hidden":"true"},"#",-1),fn=n("p",null,[s("defer是go语言提供的一种用于注册延迟调用的机制：让函数或者语句在当前函数执行完毕("),n("strong",null,"包括return正常结束或者panic导致的异常结束"),s(")之后进行调用。defer具有以下特性：")],-1),_n=n("ul",null,[n("li",null,[n("strong",null,"延迟调用"),s("：defer在main函数return之前调用，且defer必须置于函数内部")]),n("li",null,[n("strong",null,"LIFO"),s("：后进先出，压栈式执行")]),n("li",null,[n("strong",null,"作用域"),s("：defer只和defer所在函数绑定在一起，作用域也只在这个函数，如果defer处于匿名函数中，会先调用匿名函数中的defer")])],-1),yn={id:"defer的使用场景",tabindex:"-1"},wn=n("a",{class:"header-anchor",href:"#defer的使用场景","aria-hidden":"true"},"#",-1),xn=t(`<p>defer关键字通常通常出现在一些成对出现的操作中，比如创建关闭链接、加锁解锁、打开关闭文件等操作。defer在一些资源回收的场景很有用。</p><p><strong>并发处理</strong></p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup

<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
    wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment">// 程序逻辑</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>锁场景</strong></p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>	mu<span class="token punctuation">.</span><span class="token function">RLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">defer</span> mu<span class="token punctuation">.</span><span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>资源释放</strong></p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>    <span class="token comment">// new 一个客户端 client；</span>
    cli<span class="token punctuation">,</span> err <span class="token operator">:=</span> clientv3<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span>clientv3<span class="token punctuation">.</span>Config<span class="token punctuation">{</span>Endpoints<span class="token punctuation">:</span> endpoints<span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 释放该 client ，也就是说该 client 的声明周期就只在该函数中；</span>
    <span class="token keyword">defer</span> cli<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>panic-recover</strong></p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>	<span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> v <span class="token operator">:=</span> <span class="token function">recover</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> v <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
			<span class="token boolean">_</span> <span class="token operator">=</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">&quot;PANIC=%v&quot;</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,9),qn={id:"defer的底层原理",tabindex:"-1"},Pn=n("a",{class:"header-anchor",href:"#defer的底层原理","aria-hidden":"true"},"#",-1),zn=t(`<p>defer的数据结构如下：主要由siz属性，标识返回值的内存和大小、heap属性，标识是在栈上分配还是在堆上分配、sp是栈指针、pc程序计数器、fn是传入的函数地址、link是defer链表。</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> _defer <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	siz     <span class="token builtin">int32</span> <span class="token comment">// 参数和返回值的内存大小</span>
	started <span class="token builtin">bool</span>
	heap    <span class="token builtin">bool</span>    <span class="token comment">// 区分该结构是在栈上分配的，还是对上分配的</span>
	sp        <span class="token builtin">uintptr</span>  <span class="token comment">// sp 计数器值，栈指针；</span>
	pc        <span class="token builtin">uintptr</span>  <span class="token comment">// pc 计数器值，程序计数器；</span>
	fn        <span class="token operator">*</span>funcval <span class="token comment">// defer 传入的函数地址，也就是延后执行的函数;</span>
	_panic    <span class="token operator">*</span>_panic  <span class="token comment">// panic that is running defer</span>
	link      <span class="token operator">*</span>_defer   <span class="token comment">// 链表</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>link属性将defer串成一个链表，表头是挂载在goroutine的_defer属性。defer结构只是一个头结构，后面跟着延迟函数的参数和返回值空间，内存在defer关键字执行的时候填充。</p><p>对于go语言版本1.13之前defer关键字处理被分为deferproc和deferreturn两个过程，对应着回调注册函数过程和执行注册函数链的过程。在go1.13起带来了deferprocStatck，也是用来注册回调函数，但是不同的是，<strong>deferproc是在堆上分配内存结构，deferprocStack是在栈上分配struct的结构</strong>，栈上的分配是远快于堆上的分配，所以性能得到了提升。</p><p>当 defer 外层出现显式（for）或者隐式（goto）的时候，将会导致 struct _defer 结构体分配在堆上。</p><p><strong>deferprocStack</strong></p><p>当defer结构体在栈上分配时，调用deferprocStack之前编译器就已经把defer结构体初始化好了，heap属性设置为false，保存上下文，把 caller 函数的 rsp，pc（rip） 寄存器的值保存到 _defer结构体，并且将defer结构体挂载到goroutine链表中去。</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token comment">// 进到这个函数之前，就已经在栈上分配好了内存结构（编译器分配的，rsp 往下伸展即可）</span>
<span class="token keyword">func</span> <span class="token function">deferprocStack</span><span class="token punctuation">(</span>d <span class="token operator">*</span>_defer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	gp <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment">// siz 和 fn 在进到这个函数之前已经赋值；</span>
	d<span class="token punctuation">.</span>started <span class="token operator">=</span> <span class="token boolean">false</span>
	<span class="token comment">// 标名是栈的内存</span>
	d<span class="token punctuation">.</span>heap <span class="token operator">=</span> <span class="token boolean">false</span>
	<span class="token comment">// 获取到 caller 函数的 rsp 寄存器值，并赋值到 _defer 结构 sp 字段中；</span>
	d<span class="token punctuation">.</span>sp <span class="token operator">=</span> <span class="token function">getcallersp</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token comment">// 获取到 caller 函数的 pc (rip) 寄存器值，并赋值到 _defer 结构 pc 字段中；</span>
	<span class="token comment">// 回忆起函数调用的原理，就知道 caller 的压栈的 pc 值就是 deferprocStack 的下一行指令；</span>
	d<span class="token punctuation">.</span>pc <span class="token operator">=</span> <span class="token function">getcallerpc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment">// 把这个 _defer 结构作为一个节点，挂到 goroutine 的链表中；</span>
	<span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token builtin">uintptr</span><span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d<span class="token punctuation">.</span>_panic<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span>
	<span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token builtin">uintptr</span><span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d<span class="token punctuation">.</span>link<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>gp<span class="token punctuation">.</span>_defer<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token builtin">uintptr</span><span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>gp<span class="token punctuation">.</span>_defer<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token comment">// 注意，特殊的返回，不会触发延迟调用的函数</span>
	<span class="token function">return0</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>deferproc</strong></p><p>当defer结构体在堆上分配时，结构体在函数里面初始化，调用newdefer分配结构体，并且去缓冲池中查找，如果有就直接调用，否则使用mallocgc从堆上分配内存，deferproc 接受入参 siz，fn ，这两个参数分别标识延迟函数的参数和返回值的内存大小，延迟函数地址，保存上下文，把 caller 函数的 rsp，pc（rip） 寄存器的值保存到 _defer 结构体，defer作为一个节点挂接到链表。</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">deferproc</span><span class="token punctuation">(</span>siz <span class="token builtin">int32</span><span class="token punctuation">,</span> fn <span class="token operator">*</span>funcval<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// arguments of fn follow fn</span>
	<span class="token comment">// 获取 caller 函数的 rsp 寄存器值</span>
	sp <span class="token operator">:=</span> <span class="token function">getcallersp</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	argp <span class="token operator">:=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fn<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> unsafe<span class="token punctuation">.</span><span class="token function">Sizeof</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>
	<span class="token comment">// 获取 caller 函数的 pc（rip） 寄存器值</span>
	callerpc <span class="token operator">:=</span> <span class="token function">getcallerpc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment">// 分配 struct _defer 内存结构</span>
	d <span class="token operator">:=</span> <span class="token function">newdefer</span><span class="token punctuation">(</span>siz<span class="token punctuation">)</span>
	<span class="token keyword">if</span> d<span class="token punctuation">.</span>_panic <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">&quot;deferproc: d.panic != nil after newdefer&quot;</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// _defer 结构体初始化</span>
	d<span class="token punctuation">.</span>fn <span class="token operator">=</span> fn
	d<span class="token punctuation">.</span>pc <span class="token operator">=</span> callerpc
	d<span class="token punctuation">.</span>sp <span class="token operator">=</span> sp
	<span class="token keyword">switch</span> siz <span class="token punctuation">{</span>
	<span class="token keyword">case</span> <span class="token number">0</span><span class="token punctuation">:</span>
		<span class="token comment">// Do nothing.</span>
	<span class="token keyword">case</span> sys<span class="token punctuation">.</span>PtrSize<span class="token punctuation">:</span>
		<span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token builtin">uintptr</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">deferArgs</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token builtin">uintptr</span><span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>argp<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">default</span><span class="token punctuation">:</span>
		<span class="token function">memmove</span><span class="token punctuation">(</span><span class="token function">deferArgs</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>argp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>siz<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 注意，特殊的返回，不会触发延迟调用的函数</span>
	<span class="token function">return0</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>deferreturn</strong></p><p>遍历defer链表从前往后执行，执行一个就取出一个，直到链表为空。jmpdefer 负责跳转到延迟回调函数执行指令，执行结束之后，跳转回 deferreturn里执行。_defer.sp 的值可以用来判断哪些是当前 caller 函数注册的，这样就能保证只执行自己函数注册的延迟回调函数。</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">deferreturn</span><span class="token punctuation">(</span>arg0 <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	gp <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token comment">// 获取到最前的 _defer 节点</span>
	d <span class="token operator">:=</span> gp<span class="token punctuation">.</span>_defer
	<span class="token comment">// 函数递归终止条件（d 链表遍历完成）</span>
	<span class="token keyword">if</span> d <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 获取 caller 函数的 rsp 寄存器值</span>
	sp <span class="token operator">:=</span> <span class="token function">getcallersp</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> d<span class="token punctuation">.</span>sp <span class="token operator">!=</span> sp <span class="token punctuation">{</span>
		<span class="token comment">// 如果 _defer.sp 和 caller 的 sp 值不一致，那么直接返回；</span>
		<span class="token comment">// 因为，就说明这个 _defer 结构不是在该 caller 函数注册的  </span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">switch</span> d<span class="token punctuation">.</span>siz <span class="token punctuation">{</span>
	<span class="token keyword">case</span> <span class="token number">0</span><span class="token punctuation">:</span>
		<span class="token comment">// Do nothing.</span>
	<span class="token keyword">case</span> sys<span class="token punctuation">.</span>PtrSize<span class="token punctuation">:</span>
		<span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token builtin">uintptr</span><span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arg0<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token builtin">uintptr</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">deferArgs</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">default</span><span class="token punctuation">:</span>
		<span class="token function">memmove</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arg0<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">deferArgs</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>siz<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 获取到延迟回调函数地址</span>
	fn <span class="token operator">:=</span> d<span class="token punctuation">.</span>fn
	d<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token boolean">nil</span>
	<span class="token comment">// 把当前 _defer 节点从链表中摘除</span>
	gp<span class="token punctuation">.</span>_defer <span class="token operator">=</span> d<span class="token punctuation">.</span>link
	<span class="token comment">// 释放 _defer 内存（主要是堆上才会需要处理，栈上的随着函数执行完，栈收缩就回收了）</span>
	<span class="token function">freedefer</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span>
	<span class="token comment">// 执行延迟回调函数</span>
	<span class="token function">jmpdefer</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arg0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>参数传入</strong></p><p>采用预计算参数，_defer作为头部信息，延迟回调函数和返回值在头部之后放置，参数是在defer执行的时候计算好了，而非函数执行时设置好。</p>`,16),Sn={id:"defer函数和return的执行顺序",tabindex:"-1"},An=n("a",{class:"header-anchor",href:"#defer函数和return的执行顺序","aria-hidden":"true"},"#",-1),Wn=t('<p>go 的一行<strong>函数返回 return</strong>语句对应非原子操作的多行汇编指令，包括 <strong>返回值设置</strong> 和 ret 指令执行。其中 ret 汇编指令的内容是两个，指令pc 寄存器恢复为 rsp 栈顶保存的地址，rsp 往上缩减，rsp+0x8。defer 的函数链调用是在设置了 result parameters 之后，但是在运行指令上下文返回到 caller 函数之前。所以过程如下：</p><ul><li><p>设置返回值</p></li><li><p>执行 defered 链表</p></li><li><p>ret 指令跳转到 caller 函数</p></li></ul><h3 id="waitgroup" tabindex="-1"><a class="header-anchor" href="#waitgroup" aria-hidden="true">#</a> WaitGroup？</h3><ul><li><p><strong>Add一个负数</strong>：如果计数器的值小于0会直接panic。</p></li><li><p><strong>Add在Wait之后调用</strong>：比如一些子协程开头调用Add结束调用Wait，这些 Wait无法阻塞子协程。正确做法是在开启子协程之前先Add特定的值。</p></li><li><p><strong>未置为0就重用</strong>：WaitGroup可以完成一次编排任务，计数值降为0后可以继续被其他任务所用，但是不要在还没使用完的时候就用于其他任务，这样由于带着计数值，很可能出问题。</p></li><li><p><strong>复制waitgroup</strong>：WaitGroup有nocopy字段，不能被复制。也意味着WaitGroup不能作为函数的参数。</p></li></ul>',4);function Bn(Mn,Gn){const e=p("Badge"),o=p("ExternalLinkIcon");return i(),l("div",null,[n("h3",r,[d,s(" make和new区别？"),a(e,{text:"重要",type:"danger"})]),k,v,n("h3",m,[b,s(" slice的底层实现？"),a(e,{text:"重要",type:"danger"})]),h,n("h3",g,[f,s(" slice和数组的区别？"),a(e,{text:"重要",type:"danger"})]),_,y,w,x,q,n("h3",P,[z,s(" slice的扩容机制？"),a(e,{text:"重要",type:"danger"})]),S,n("h3",A,[W,s(" map的底层数据结构？"),a(e,{text:"掌握",type:"tip"})]),B,n("h3",M,[G,s(" bucket是如何工作的？"),a(e,{text:"了解",type:"info"})]),N,C,E,n("h3",I,[L,s(" map的查找过程？"),a(e,{text:"了解",type:"info"})]),V,n("h3",D,[R,s(" map的扩容过程？"),a(e,{text:"了解",type:"info"})]),T,n("p",null,[s("使用场景："),n("a",j,[s("https://golang.org/pkg/sync/#Map"),a(o)])]),F,H,n("h3",K,[O,s(" channel的概念？"),a(e,{text:"重要",type:"danger"})]),U,n("h3",X,[Y,s(" channel有哪些状态？"),a(e,{text:"重要",type:"danger"})]),Z,n("h3",$,[J,s(" 如何判断channel已经关闭？"),a(e,{text:"重要",type:"danger"})]),Q,n("h3",nn,[sn,s(" channel的底层实现原理？"),a(e,{text:"了解",type:"info"})]),an,n("h3",en,[tn,s(" channel发送数据和接收数据的过程？"),a(e,{text:"了解",type:"info"})]),pn,n("h3",on,[cn,s(" channel是否线程安全的？"),a(e,{text:"掌握",type:"tip"})]),ln,un,n("h3",rn,[dn,s(" channel如何实现线程安全的？"),a(e,{text:"掌握",type:"tip"})]),kn,n("h3",vn,[mn,s(" channel的应用场景？"),a(e,{text:"掌握",type:"tip"})]),bn,n("h3",hn,[gn,s(" defer的概述？"),a(e,{text:"重要",type:"danger"})]),fn,_n,n("h3",yn,[wn,s(" defer的使用场景？"),a(e,{text:"重要",type:"danger"})]),xn,n("h3",qn,[Pn,s(" defer的底层原理？"),a(e,{text:"掌握",type:"tip"})]),zn,n("h3",Sn,[An,s(" defer函数和return的执行顺序？"),a(e,{text:"了解",type:"info"})]),Wn])}const Cn=c(u,[["render",Bn],["__file","keyword.html.vue"]]);export{Cn as default};
