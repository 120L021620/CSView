import{_ as s,X as a,Y as i,Z as t,$ as e,a0 as n,a2 as d,H as r}from"./framework-edbf9e3c.js";const c={},l={id:"操作系统中的缺页中断",tabindex:"-1"},h=t("a",{class:"header-anchor",href:"#操作系统中的缺页中断","aria-hidden":"true"},"#",-1),_=d('<p><strong>缺页</strong>：内存管理时系统采用的是虚拟内存，虚拟内存并不能与实际内存建立完全的映射关系。缺页就是虚拟内存无法与实际内存建立映射的一种情况。</p><p><strong>中断</strong>：中断是指计算机在执行程序的过程中，当出现异常情况或特殊请求时，计算机停止现行程序的运行，转向对这些异常情况或特殊请求的处理，处理结束后再返回现行程序的间断处，继续执行原程序。</p><p>缺页中断就是要访问的页不在主存，需要操作系统将其调入主存后再进行访问。当访问已映射在虚拟地址空间中，但是并未被加载在物理内存中的一个分页时，由CPU的MMU所发出的中断。通常情况下，用于处理此中断的程序是操作系统的一部分。如果操作系统判断此次访问是有效的，那么操作系统会尝试将相关的分页从硬盘上的虚拟内存文件中调入内存。而如果访问是不被允许的，那么操作系统通常会结束相关的进程。</p><div class="hint-container tip"><p class="hint-container-title">补充</p><p><strong>缺页中断发生时的事件顺序</strong>：</p><p>硬件陷入内核，在堆栈中保存程序计数器，将当前指令的各种状态信息保存在特殊的 CPU 寄存器中；保存通用寄存器和其他易失的信息，以免被操作系统破坏；当操作系统发现一个缺页中断时，尝试发现需要哪个虚拟页面。通常一个硬件寄存器包含了这一信息，如果没有的话，操作系统必须检索程序计数器，取出这条指令，用软件分析这条指令，看看它在缺页中断时正在做什么；</p><p>一旦知道了发生缺页中断的虚拟地址，操作系统检查这个地址是否有效，并检查存取与保护是否一致。如果不一致，向进程发出一个信号或杀掉该进程。如果地址有效且没有保护错误发生，系统则检查是否有空闲页框。如果没有空闲页框，执行页面置换算法寻找一个页面来淘汰；</p><p>如果选择的页框“脏”了，安排该页写回磁盘，并发生一次上下文切换，挂起产生缺页中断的进程，让其他进程运行直至磁盘传输结束。无论如何，该页框被标记为忙，以免因为其他原因而被其他进程占用；</p><p>一旦页框“干净”后，操作系统查找所需页面在磁盘上的地址，通过磁盘操作将其装入。该页面被装入后，产生缺页中断的进程仍然被挂起，并且如果有其他可运行的用户进程，则选择另一个用户进程运行；</p><p>当磁盘中断发生时，表明该页已经被装入，页表已经更新可以反映它的位置，页框也被标记为正常状态；</p><p>恢复发生缺页中断指令以前的状态，程序计数器重新指向这条指令；</p><p>调度引发缺页中断的进程，操作系统返回调用它的汇编语言程序；</p><p>该程序恢复寄存器和其他状态信息，返回到用户空间继续执行。</p></div>',4),p={id:"操作系统如何进行内存管理",tabindex:"-1"},u=t("a",{class:"header-anchor",href:"#操作系统如何进行内存管理","aria-hidden":"true"},"#",-1),f=t("p",null,"更新中……",-1),x={id:"什么时候会由用户态陷入内核态",tabindex:"-1"},m=t("a",{class:"header-anchor",href:"#什么时候会由用户态陷入内核态","aria-hidden":"true"},"#",-1),g=t("ul",null,[t("li",null,[t("strong",null,"发生系统调用时"),e("：这是处于用户态的进程主动请求切换到内核态的一种方式。用户态的进程通过系统调用申请使用操作系统提供的系统调用服务例程来处理任务。而系统调用的机制，其核心是使用软中断。")]),t("li",null,[t("strong",null,"产生异常时"),e("：当CPU执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行的进程切换到处理此异常的内核相关的程序中，也就是转到了内核态，如缺页异常。")]),t("li",null,[t("strong",null,"外部设备产生中断时"),e("：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作的完成。")])],-1),b={id:"操作系统中-虚拟地址与物理地址之间如何映射",tabindex:"-1"},v=t("a",{class:"header-anchor",href:"#操作系统中-虚拟地址与物理地址之间如何映射","aria-hidden":"true"},"#",-1),y=t("p",null,"虚拟内存地址由页号和偏移量组成。虚拟地址到物理地址的映射以页为单位，通过页表把虚拟地址所在的虚拟页映射到一个物理页，然后再在这个物理页上根据页内偏移找到物理地址，从而完成映射。",-1),U={id:"操作系统中malloc的实现原理",tabindex:"-1"},C=t("a",{class:"header-anchor",href:"#操作系统中malloc的实现原理","aria-hidden":"true"},"#",-1),N=t("p",null,"malloc 函数的实质是它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表。 调用 malloc()函数时，它沿着连接表寻找一个大到足以满足用户请求所需要的内存块。(如果没有搜索到，那么就会用sbrk()才推进brk指针来申请内存空间)。 然后，将该内存块一分为二(一块的大小与用户申请的大小相等，另一块的大小就是剩下来的字节)。 接下来，将分配给用户的那块内存存储区域传给用户，并将剩下的那块(如果有的话)返回到连接表上。 调用 free 函数时，它将用户释放的内存块连接到空闲链表上。",-1),B={id:"malloc创建的对象在堆还是栈中",tabindex:"-1"},P=t("a",{class:"header-anchor",href:"#malloc创建的对象在堆还是栈中","aria-hidden":"true"},"#",-1),V=t("p",null,"更新中......",-1),k={id:"lvs的nat、tun、dr原理及区别",tabindex:"-1"},T=t("a",{class:"header-anchor",href:"#lvs的nat、tun、dr原理及区别","aria-hidden":"true"},"#",-1);function M(S,A){const o=r("Badge");return a(),i("div",null,[t("h3",l,[h,e(" 操作系统中的缺页中断？"),n(o,{text:"掌握",type:"tip"})]),_,t("h3",p,[u,e(" 操作系统如何进行内存管理？"),n(o,{text:"了解",type:"info"})]),f,t("h3",x,[m,e(" 什么时候会由用户态陷入内核态？"),n(o,{text:"掌握",type:"tip"})]),g,t("h3",b,[v,e(" 操作系统中，虚拟地址与物理地址之间如何映射？"),n(o,{text:"掌握",type:"tip"})]),y,t("h3",U,[C,e(" 操作系统中malloc的实现原理？"),n(o,{text:"掌握",type:"tip"})]),N,t("h3",B,[P,e(" malloc创建的对象在堆还是栈中？"),n(o,{text:"了解",type:"info"})]),V,t("h3",k,[T,e(" LVS的NAT、TUN、DR原理及区别？"),n(o,{text:"了解",type:"info"})])])}const E=s(c,[["render",M],["__file","other.html.vue"]]);export{E as default};
