import{_ as n,W as s,X as a,Y as t,Z as e,$ as l,a1 as o,C as r}from"./framework-17a5d3b6.js";const c={},d={id:"常用的linux命令",tabindex:"-1"},p=t("a",{class:"header-anchor",href:"#常用的linux命令","aria-hidden":"true"},"#",-1),g=t("ul",null,[t("li",null,"find 查找文件或目录的路径"),t("li",null,"pwd 显示当前所在路径"),t("li",null,"ls 列出当前目录所有子目录与文件"),t("li",null,"cd 切换工作目录"),t("li",null,"man 查看帮助手册"),t("li",null,"grep 查找文件或其他内容里符合条件的字符串"),t("li",null,"chmod 控制用户对文件的权限的命令"),t("li",null,"ps 列出系统中当前运行的进程"),t("li",null,"kill 向执行中进程发出信号")],-1),h={id:"linux页大小是多少",tabindex:"-1"},u=t("a",{class:"header-anchor",href:"#linux页大小是多少","aria-hidden":"true"},"#",-1),_=t("p",null,"默认为4KB",-1),f={id:"linux下如何查看cpu荷载-正在运行的线程-某个端口对应的进程",tabindex:"-1"},m=t("a",{class:"header-anchor",href:"#linux下如何查看cpu荷载-正在运行的线程-某个端口对应的进程","aria-hidden":"true"},"#",-1),x=t("p",null,[e("使用"),t("code",null,"top"),e("命令查看CPU使用情况，定位占用CPU过高的进程PID")],-1),I=t("p",null,[e("使用"),t("code",null,"top -H -p <进程PID>"),e(" 定位对应进程中占用资源最高的线程id")],-1),b=t("p",null,"两个方法查看占用端口进程",-1),P=t("ol",null,[t("li",null,"lsof -i:端口号"),t("li",null,"netstat -tunlp|grep 端口号")],-1),O={id:"linux下如何排查cpu以及内存占用过多",tabindex:"-1"},D=t("a",{class:"header-anchor",href:"#linux下如何排查cpu以及内存占用过多","aria-hidden":"true"},"#",-1),C=o("<p><strong>排查CPU占用过高</strong></p><ol><li>使用<code>top</code>命令定位占用CPU过高的进程PID</li><li>使用<code>top -H -p &lt;进程PID&gt;</code> 定位进程中占用资源最高的线程id 然后对线程进行排查</li></ol><p><strong>排查内存占用过高</strong></p><ol><li>使用<code>cat /proc/meminfo</code>命令查看内存使用情况</li><li>使用<code>free</code>命令查看内存使用情况</li><li>使用<code>vmstat</code>命令显示系统资源实时和平均使用情况</li></ol>",4),L={id:"linux如何查看实时的滚动日志",tabindex:"-1"},y=t("a",{class:"header-anchor",href:"#linux如何查看实时的滚动日志","aria-hidden":"true"},"#",-1),w=t("ul",null,[t("li",null,"使用tail命令查看日志文件。使用 -f 选项可以跟踪文件末尾的内容，这表示它会持续显示被新添加到文件中的内容。")],-1),U=t("p",null,[t("code",null,"tail -f location_of_log_file")],-1),T=t("ul",null,[t("li",null,"使用multitail同时监视多个日志文件")],-1),v=t("p",null,[t("code",null,"multitail log_file_1 log_file_2")],-1),M=t("ul",null,[t("li",null,"使用less命令实时查看日志文件")],-1),k=t("p",null,[t("code",null,"less +F log_file")],-1),A={id:"linux零拷贝的原理",tabindex:"-1"},z=t("a",{class:"header-anchor",href:"#linux零拷贝的原理","aria-hidden":"true"},"#",-1),F=o('<p>传统I/O工作流如下图所示 <img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/操作系统/零拷贝/传统文件传输.png" alt="传统I/O工作流" loading="lazy"></p><p>零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术。通过减少用户态与内核态上下文切换和减少内存拷贝次数实现，通常实现方式有3种：mmap+write、sendfile、sendfile+DMA scatter/gather</p><ul><li><p><strong>mmap+write</strong>： mmap() 系统调用函数会直接把内核缓冲区里的数据「映射」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。包含2次系统调用，3次数据拷贝(2次DMA和1次CPU拷贝)</p><ol><li>用户进程通过mmap方法向操作系统内核发起IO调用，<strong>上下文从用户态切换为内核态</strong>。</li><li>CPU利用DMA控制器，把数据从硬盘中拷贝到内核缓冲区。</li><li><strong>上下文从内核态切换回用户态</strong>，mmap方法返回。</li><li>用户进程通过write方法向操作系统内核发起IO调用，<strong>上下文从用户态切换为内核态</strong>。</li><li>CPU将内核缓冲区的数据拷贝到的socket缓冲区。</li><li>CPU利用DMA控制器，把数据从socket缓冲区拷贝到网卡，<strong>上下文从内核态切换回用户态</strong>，write调用返回。 <img src="https://ask.qcloudimg.com/http-save/yehe-7197959/42e23f1db8479f4c6912f0593c8fea2d.png?imageView2/2/w/1620" alt="" loading="lazy"></li></ol></li><li><p><strong>sendfile</strong>： 在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用函数 sendfile()。它可以替代前面的 read() 和 write() 这两个系统调用，减少一次系统调用。包含1次系统调用，3次数据拷贝(2次DMA和1次CPU拷贝)</p><ol><li>用户进程发起sendfile系统调用，上下文(切换1)从用户态转向内核态。</li><li>DMA控制器，把数据从硬盘中拷贝到内核缓冲区。</li><li>CPU将读缓冲区中数据拷贝到socket缓冲区。</li><li>DMA控制器，异步把数据从socket缓冲区拷贝到网卡。</li><li>上下文(切换2)从内核态切换回用户态，sendfile调用返回。 <img src="https://ask.qcloudimg.com/http-save/yehe-7197959/314a45c2ce4f001c136a6f0941cafc39.png?imageView2/2/w/1620" alt="" loading="lazy"></li></ol></li><li><p><strong>sendfile+DMA scatter/gather</strong>： linux 2.4版本之后，对sendfile做了优化升级，引入SG-DMA技术，其实就是对DMA拷贝加入了scatter/gather操作，它可以直接从内核空间缓冲区中将数据读取到网卡。使用这个特点搞零拷贝，即还可以多省去一次CPU拷贝。包含1次系统调用，2次数据拷贝(2次DMA拷贝)。</p><ol><li>用户进程发起sendfile系统调用，上下文(切换1)从用户态转向内核态。</li><li>DMA控制器，把数据从硬盘中拷贝到内核缓冲区。</li><li>CPU把内核缓冲区中的文件描述符信息(包括内核缓冲区的内存地址和偏移量)发送到socket缓冲区。</li><li>DMA控制器根据文件描述符信息，直接把数据从内核缓冲区拷贝到网卡。</li><li>上下文(切换2)从内核态切换回用户态，sendfile调用返回。 <img src="https://ask.qcloudimg.com/http-save/yehe-7197959/979075ba489c160e61dcb19426149620.png?imageView2/2/w/1620" alt="" loading="lazy"></li></ol></li></ul>',3),V={id:"linux虚拟内存的页面置换算法",tabindex:"-1"},B=t("a",{class:"header-anchor",href:"#linux虚拟内存的页面置换算法","aria-hidden":"true"},"#",-1),S=o("<ul><li><p><strong>最佳置换算法(OPT)</strong>：对于每一个逻辑页面，计算它的下一次访问到现在的时间，选取最后访问的剔除，这是一种理想算法，通常用来计算最优解与其他算法比较</p></li><li><p><strong>先进先出置换算法(FIFO)</strong>：使用队列对页进行排序，选取最先进入的页踢出</p></li><li><p><strong>最近最少未使用算法(LRU)</strong>：选择一段时间内最久未使用的那个页面踢出</p></li><li><p><strong>最不经常使用算法(LFU)</strong>：统计页面的访问次数，选择一段时间内访问次数最少的页面踢出，这个算法需要统计页面使用次数，开销较大</p></li><li><p><strong>时钟页面置换算法(CLOCK)</strong>：系统中的所有页都放在一个循环列表(环形链表)中，时钟指针开始指向某个特定的页，所有页初始化为0，当必须进行页替换时，操作系统检查当前指向的页P的使用位是1还是0，如果是1，则意味着页面P最近被使用过，因此不适合被替换. 然后，P的使用位设置为0，时钟指针指下一页，该算法一直持续到找到一个使用位为0的页，使用位为0意味着这个页最近没有被使用过，最坏的情况下，如果所有的页都已经被使用了，那么就将所有页的使用位都设置为0</p></li></ul>",1),G={id:"linux系统态与用户态-什么时候会进入系统态",tabindex:"-1"},N=t("a",{class:"header-anchor",href:"#linux系统态与用户态-什么时候会进入系统态","aria-hidden":"true"},"#",-1),q=o("<p>当一个任务(进程)执行系统调用而陷入内核代码中执行时，我们就称进程处于<strong>内核态</strong>。此时处理器处于特权级最高的(0级)内核代码。当进程处于内核态时，执行的内核代码会使用当前的内核栈。每个进程都有自己的内核栈。</p><p>当进程在执行用户自己的代码时，则称其处于<strong>用户态</strong>。即此时处理器在特权级最低的用户代码中运行。当正在执行用户程序而突然中断时，此时用户程序也可以象征性地处于进程的内核态。因为中断处理程序将使用当前进程的内核态。</p><p>在发生<strong>系统调用</strong>、<strong>产生异常</strong>或<strong>外部设备产生中断</strong>时，进程会从用户态进入内核态。</p>",3),H={id:"linux中虚拟内存和物理内存有什么区别-有什么优点",tabindex:"-1"},K=t("a",{class:"header-anchor",href:"#linux中虚拟内存和物理内存有什么区别-有什么优点","aria-hidden":"true"},"#",-1),j=t("p",null,[t("strong",null,"物理内存"),e("就是系统硬件提供的内存大小，是真正的内存。相对于物理内存，Linux中的"),t("strong",null,"虚拟内存"),e("是为了满足物理内存的不足而提出的策略，它是利用磁盘空间虚拟出的一块逻辑内存。用作虚拟内存的磁盘空间被称为交换空间(又称 swap 空间)。")],-1),E=t("p",null,"这种策略的优点在于作为物理内存的扩展，Linux 会在物理内存不足时，使用交换分区的虚拟内存，更详细地说，就是内核会将暂时不用的内存块信息写到交换空间，这样一来，物理内存得到了释放，这块内存就可以用于其他目的，当需要用到原始的内容时，这些信息会被重新从交换空间读入物理内存。",-1),R={id:"linux的i-o模型",tabindex:"-1"},W=t("a",{class:"header-anchor",href:"#linux的i-o模型","aria-hidden":"true"},"#",-1),X=o('<p>Linux有五种IO模型，<strong>阻塞式IO、非阻塞式IO、IO复用、信号驱动式IO、异步IO</strong>。</p><p><strong>阻塞式IO模型</strong></p><p>用户进程尝试读取数据，可是数据尚未达到(未准备好)此时内核也是处于等待状态，而用户进程就是阻塞状态。等到数据已经到达并来到了内核缓冲区，代表已经就绪；但是数据还只是在内核空间中，并没有被拷贝到用户空间中，所以这时候用户进程还是不能处理数据，继续阻塞。直到数据拷贝到用户空间中，用户进程才解除阻塞。 <img src="https://pic3.zhimg.com/80/v2-ca5e9b983f97bcfaa06f1bcaed3abbf2_1440w.webp" alt="" loading="lazy"></p><p><strong>非阻塞式IO模型</strong></p><p>在非阻塞IO中，recvfrom操作会立即返回结果而不是阻塞用户进程。</p><p>用户进程尝试读取数据，数据尚未达到(未准备好)此时内核是处于等待状态；但是由于是非阻塞IO，此时用户会返回异常，即用户进程并不会阻塞等待；用户进程拿到异常后，再次尝试读取，循环往复，直到数据就绪。等内存缓冲区内数据就绪后，数据还只是在内核空间中，并没有被拷贝到用户空间中，所以这时候用户进程还是不能处理数据，继续阻塞。直到数据拷贝到用户空间中，用户进程才解除阻塞，开始处理数据。 <img src="https://pic3.zhimg.com/80/v2-e1545bae41027e4ca795e22f00e7e8f2_1440w.webp" alt="" loading="lazy"></p><p><strong>IO多路复用模型(异步阻塞IO)</strong></p><p>上述模型在单线程下只能依次处理单个IO事件，IO多路复用利用单个线程来同时监听多个FD，并在某个FD可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。监听方式有select、poll、epoll。</p><p>用户进程调用select，指定要监听的FD集合，然后内核监听FD对应的多个socket，任意一个或多个socket数据就绪则返回readable，此过程中用户进程阻塞。</p><p>当有socket就绪后，用户进程找到就绪的socket依次调用recvfrom读取数据，内核将数据拷贝到用户空间后用户进程处理数据。</p><figure><img src="https://pic1.zhimg.com/80/v2-d4f222f3493d732ce5b4bafa72c6b210_1440w.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>信号驱动IO</strong></p><p>信号驱动IO是与内核建立SIGIO的信号关联并设置回调，当内核有FD就绪时，会发出SIGIO信号通知用户，期间用户应用可以执行其它业务，无需阻塞等待。</p><p>用户进程调用sigaction，注册信号处理函数，随后内核返回成功，开始监听FD。用户进程不阻塞等待，可以执行其它业务，当内核数据就绪后，回调用户进程的SIGIO处理函数。</p><p>然后用户进程收到SIGIO回调信号调用recvfrom，读取数据，内核将数据拷贝到用户空间后用户进程处理数据。</p><figure><img src="https://pic2.zhimg.com/80/v2-c4f9aa68cbf6ddf37d49de61d4d5b989_1440w.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>异步IO</strong></p><p>异步IO的整个过程都是非阻塞的，用户进程调用完异步API后就可以去做其它事情，内核等待数据就绪并拷贝到用户空间后才会递交信号，通知用户进程。</p><p>用户进程调用aio_read，创建信号回调函数，内核等待数据就绪，然后用户进程无需阻塞，可以做任何事情。</p><p>等内核数据就绪后，内核数据拷贝到用户缓冲区，拷贝完成，内核递交信号触发aio_read中的回调函数，用户进程处理数据。</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/b5fdbf8016c87b614bf123b157e3da81.png#pic_center" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',21),Y={id:"traceroute命令的原理",tabindex:"-1"},Z=t("a",{class:"header-anchor",href:"#traceroute命令的原理","aria-hidden":"true"},"#",-1),$=t("p",null,"Traceroute程序的设计是利用ICMP及IP header的TTL(Time To Live)栏位(field)。",-1),J=t("p",null,"首先，traceroute送出一个TTL是1的IP datagram(其实，每次送出的为3个40字节的包，包括源地址，目的地址和包发出的时间标签)到目的地，当路径上的第一个路由器(router)收到这个datagram时，它将TTL减1。此时，TTL变为0了，所以该路由器会将此datagram丢掉，并送回一个「ICMP time exceeded」消息(包括发IP包的源地址，IP包的所有内容及路由器的IP地址)，traceroute 收到这个消息后，便知道这个路由器存在于这个路径上，接着traceroute 再送出另一个TTL是2 的datagram，发现第2个路由器...，traceroute 每次将送出的datagram的TTL加1来发现另一个路由器，这个重复的动作一直持续到某个datagram抵达目的地。当datagram到达目的地后，该主机并不会送回ICMP time exceeded消息，因为它已是目的地了。Traceroute在送出UDP datagrams到目的地时，它所选择送达的port number 是一个一般应用程序都不会用的号码(30000 以上)，所以当此UDP datagram 到达目的地后该主机会送回一个「ICMP port unreachable」的消息，而当traceroute 收到这个消息时，便知道目的地已经到达了。",-1);function Q(tt,et){const i=r("Badge");return s(),a("div",null,[t("h3",d,[p,e(" 常用的Linux命令？"),l(i,{text:"重点",type:"danger"})]),g,t("h3",h,[u,e(" Linux页大小是多少？"),l(i,{text:"了解",type:"info"})]),_,t("h3",f,[m,e(" Linux下如何查看CPU荷载，正在运行的线程，某个端口对应的进程？"),l(i,{text:"掌握",type:"tip"})]),x,I,b,P,t("h3",O,[D,e(" Linux下如何排查CPU以及内存占用过多？"),l(i,{text:"了解",type:"info"})]),C,t("h3",L,[y,e(" Linux如何查看实时的滚动日志？"),l(i,{text:"了解",type:"info"})]),w,U,T,v,M,k,t("h3",A,[z,e(" Linux零拷贝的原理？"),l(i,{text:"重点",type:"danger"})]),F,t("h3",V,[B,e(" Linux虚拟内存的页面置换算法？"),l(i,{text:"掌握",type:"tip"})]),S,t("h3",G,[N,e(" Linux系统态与用户态，什么时候会进入系统态？"),l(i,{text:"掌握",type:"tip"})]),q,t("h3",H,[K,e(" Linux中虚拟内存和物理内存有什么区别？有什么优点？"),l(i,{text:"了解",type:"info"})]),j,E,t("h3",R,[W,e(" Linux的I/O模型？"),l(i,{text:"掌握",type:"tip"})]),X,t("h3",Y,[Z,e(" traceroute命令的原理？"),l(i,{text:"了解",type:"info"})]),$,J])}const lt=n(c,[["render",Q],["__file","linux.html.vue"]]);export{lt as default};
