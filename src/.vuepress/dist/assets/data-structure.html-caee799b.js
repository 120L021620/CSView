import{_ as l,X as n,Y as o,Z as t,$ as s,a0 as e,a2 as p,H as r}from"./framework-edbf9e3c.js";const a={},g={id:"redis数据类型",tabindex:"-1"},d=t("a",{class:"header-anchor",href:"#redis数据类型","aria-hidden":"true"},"#",-1),c=p('<p>主要有STRING，LIST，ZSET，SET，HASH。</p><p><strong>STRING</strong></p><p>String类型的底层的数据结构实现主要是SDS(简单动态字符串)。应用场景主要有：</p><ul><li>缓存对象：例如可以用STRING缓存整个对象的JSON。</li><li>计数：Redis处理命令是单线程，所以执行命令的过程是原子的，因此String数据类型适合计数场景，比如计算访问次数、点赞、转发、库存数量等等。</li><li>分布式锁：可以利用SETNX命令。</li><li>共享Session信息：服务器都会去同一个Redis获取相关的Session信息，解决了分布式系统下Session存储的问题。</li></ul><p><strong>LIST</strong></p><p>List 类型的底层数据结构是由<strong>双向链表或压缩列表</strong>实现的：</p><ul><li>如果列表的元素个数小于 512 个，列表每个元素的值都小于 64 字节，Redis 会使用<strong>压缩列表</strong>作为 List 类型的底层数据结构；</li><li>如果列表的元素不满足上面的条件，Redis 会使用<strong>双向链表</strong>作为 List 类型的底层数据结构；</li></ul><p>在 Redis 3.2 版本之后，List 数据类型底层数据结构只由 quicklist 实现，替代了双向链表和压缩列表。在 Redis 7.0 中，压缩列表数据结构被废弃，由 listpack 来实现。应用场景主要有：</p><ul><li><strong>微信朋友圈点赞</strong>：要求按照点赞顺序显示点赞好友信息，如果取消点赞，移除对应好友信息。</li><li><strong>消息队列</strong>：可以使用左进右出的命令组成来完成队列的设计。比如：数据的生产者可以通过Lpush命令从左边插入数据，多个数据消费者，可以使用BRpop命令阻塞的”抢”列表尾部的数据。</li></ul><p><strong>HASH</strong></p><p>Hash 类型的底层数据结构是由压缩列表或哈希表实现的：</p><ul><li>如果哈希类型元素个数小于 512 个，所有值小于 64 字节的话，Redis 会使用压缩列表作为 Hash 类型的底层数据结构；</li><li>如果哈希类型元素不满足上面条件，Redis 会使用哈希表作为 Hash 类型的底层数据结构。</li></ul><p>在Redis 7.0 中，压缩列表数据结构被废弃，交由 listpack 来实现。应用场景主要有：</p><ul><li><strong>缓存对象</strong>：一般对象用 String + Json 存储，对象中某些频繁变化的属性可以考虑抽出来用 Hash 类型存储。</li><li><strong>购物车</strong>：以用户 id 为 key，商品 id 为 field，商品数量为 value，恰好构成了购物车的3个要素。</li></ul><p><strong>SET</strong></p><p>Set 类型的底层数据结构是由<strong>哈希表或整数集合</strong>实现的：</p><ul><li>如果集合中的元素都是整数且元素个数小于 512个，Redis 会使用<strong>整数集合</strong>作为 Set 类型的底层数据结构；</li><li>如果集合中的元素不满足上面条件，则 Redis 使用<strong>哈希表</strong>作为 Set 类型的底层数据结构。</li></ul><p>应用场景主要有：</p><ul><li><strong>点赞</strong>：key 是文章id，value 是用户id。</li><li><strong>共同关注</strong>：Set 类型支持交集运算，所以可以用来计算共同关注的好友、公众号等。key 可以是用户id，value 则是已关注的公众号的id。</li><li><strong>抽奖活动</strong>：存储某活动中中奖的用户名 ，Set 类型因为有去重功能，可以保证同一个用户不会中奖两次。</li></ul><div class="hint-container warning"><p class="hint-container-title">提示</p><p>Set 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致 Redis 实例阻塞。在主从集群中，为了避免主库因为 Set 做聚合计算（交集、差集、并集）时导致主库被阻塞，可以选择一个从库完成聚合统计，或者把数据返回给客户端，由客户端来完成聚合统计。</p></div><p><strong>Zset</strong></p><p>Zset类型(Sorted Set，有序集合)可以根据元素的权重来排序，可以自己来决定每个元素的权重值。比如说，可以根据元素插入Sorted Set 的时间确定权重值，先插入的元素权重小，后插入的元素权重大。应用场景主要有：</p><ul><li><p>在面对需要展示最新列表、排行榜等场景时，如果数据更新频繁或者需要分页显示，可以优先考虑使用 Zset。</p></li><li><p><strong>排行榜</strong>：有序集合比较典型的使用场景就是排行榜。例如学生成绩的排名榜、游戏积分排行榜、视频播放排名、电商系统中商品的销量排名等。</p></li></ul><p><strong>BitMap</strong></p><p>bit 是计算机中最小的单位，使用它进行储存将非常节省空间，特别适合一些数据量大且使用二值统计的场景。可以用于签到统计、判断用户登陆态等操作。</p><p><strong>HyperLogLog</strong></p><p>HyperLogLog用于基数统计，统计规则是基于概率完成的，不准确，标准误算率是 0.81%。优点是，在输入元素的数量或者体积非常非常大时，所需的内存空间总是固定的、并且很小。比如百万级网页 UV 计数等；</p><p><strong>GEO</strong></p><p>主要用于存储地理位置信息，并对存储的信息进行操作。底层是由Zset实现的，使用GeoHash编码方法实现了经纬度到Zset中元素权重分数的转换，这其中的两个关键机制就是「对二维地图做区间划分」和「对区间进行编码」。一组经纬度落在某个区间后，就用区间的编码值来表示，并把编码值作为Zset元素的权重分数。</p><p><strong>Stream</strong></p><p>Redis专门为消息队列设计的数据类型。相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息ID，支持以消费组形式消费数据。</p><p>之前方法缺陷：不能持久化，无法可靠的保存消息，并且对于离线重连的客户端不能读取历史消息。</p>',32),u={id:"redis底层数据结构",tabindex:"-1"},h=t("a",{class:"header-anchor",href:"#redis底层数据结构","aria-hidden":"true"},"#",-1),S=p('<p><strong>SDS</strong></p><p>SDS 不仅可以保存文本数据，还可以保存二进制数据。</p><p>O(1)复杂度获取字符串长度，因为有Len属性。</p><p>不会发生缓冲区溢出，因为 SDS 在拼接字符串之前会检查空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。</p><p><strong>链表</strong></p><p>节点是一个双向链表，在双向链表基础上封装了listNode这个数据结构。包括链表节点数量 len、以及可以自定义实现的 dup、free、match 函数。</p><ul><li>listNode 链表节点的结构里带有 prev 和 next 指针，获取某个节点的前置节点或后置节点的时间复杂度只需O(1)，而且这两个指针都可以指向 NULL，所以链表是无环链表；</li><li>list 结构因为提供了表头指针 head 和表尾节点 tail，所以获取链表的表头节点和表尾节点的时间复杂度只需O(1)；</li></ul><p>缺陷：</p><ul><li>链表每个节点之间的内存都是不连续的，无法很好利用 CPU 缓存。能很好利用CPU缓存的数据结构是数组，因为数组的内存是连续的。</li><li>保存一个链表节点的值都需要一个链表节点结构头的分配，内存开销较大。</li></ul><p><strong>压缩列表</strong></p><p>压缩列表是由连续内存块组成的顺序型数据结构，类似于数组。不仅可以利用 CPU 缓存，而且会针对不同长度的数据，进行相应编码，这种方法可以有效地节省内存开销。不能保存过多的元素，否则查询效率就会降低；新增或修改某个元素时，压缩列表占用的内存空间需要重新分配，甚至可能引发连锁更新的问题。</p><p><strong>缺陷：</strong></p><ul><li><p>空间扩展操作也就是重新分配内存，因此连锁更新一旦发生，就会导致压缩列表占用的内存空间要多次重新分配，直接影响到压缩列表的访问性能。</p></li><li><p>如果保存的元素数量增加了，或是元素变大了，会导致内存重新分配，会有连锁更新的问题。</p></li><li><p>压缩列表只会用于保存的节点数量不多的场景，只要节点数量足够小，即使发生连锁更新也能接受。</p></li></ul><p><strong>哈希</strong></p><p>哈希表是一种保存键值对(key-value)的数据结构。优点在于能以O(1)的复杂度快速查询数据。Redis 采用了拉链法来解决哈希冲突，在不扩容哈希表的前提下，将具有相同哈希值的数据串起来，形成链接。渐进式哈希的过程如下：</p><p>Redis定义一个dict结构体，这个结构体里定义了<strong>两个哈希表(ht[2])</strong>。</p><ul><li>给ht2分配空间；</li><li>在 rehash 进行期间，每次哈希表元素进行新增、删除、查找或者更新操作时，Redis 除了会执行对应的操作之外，还会顺序将ht1中索引位置上的所有数据迁移到ht2上；</li><li>随着处理客户端发起的哈希表操作请求数量越多，最终在某个时间点会把「哈希表 1 」的所有 key-value 迁移到「哈希表 2」，从而完成 rehash 操作。</li></ul><div class="hint-container tip"><p class="hint-container-title">渐进式哈希的触发条件？</p><p><strong>触发条件</strong>：</p><p>负载因子 = 哈希表已保存节点数/哈希表大小</p><p>当负载因子大于等于 1 ，没有执行 RDB 快照或没有进行 AOF 重写的时候，就会进行 rehash 操作。</p><p>当负载因子大于等于 5 时，此时说明哈希冲突非常严重了，不管有没有有在执行 RDB 快照或 AOF 重写，都会强制进行 rehash 操作。</p></div><p><strong>跳表</strong></p><p>一种多层的有序链表，能快读定位数据。当数据量很大时，跳表的查找复杂度就是O(logN)。</p><p>节点同时保存元素和元素的权重，每个跳表节点都有一个后向指针，指向前一个节点，目的是为了方便从跳表的尾节点开始访问节点，为了倒序查找时方便。跳表是一个带有层级关系的链表，而且每一层级可以包含多个节点，每一个节点通过指针连接起来。Zset数组中一个属性是level数组，一个level数组就代表跳表的一层，定义了指向下一个节点的指针和跨度。</p><div class="hint-container tip"><p class="hint-container-title">跳表的查找过程？</p><p>查找一个跳表节点的过程时，跳表会从头节点的最高层开始，逐一遍历每一层。在遍历某一层的跳表节点时，会用跳表节点中的 SDS 类型的元素和元素的权重来进行判断：</p><ul><li>如果当前节点的权重小于要查找的权重时，跳表就会访问该层上的下一个节点。</li><li>如果当前节点的权重等于要查找的权重时，并且当前节点的 SDS 类型数据小于要查找的数据时，跳表就会访问该层上的下一个节点。</li></ul><p>如果上面两个条件都不满足，或者下一个节点为空时，跳表就会使用目前遍历到的节点的 level 数组里的下一层指针，然后沿着下一层指针继续查找。</p></div><p>跳表的相邻两层的节点数量的比例会影响跳表的查询性能。相邻两层的节点数量最理想的比例是 2:1，查找复杂度可以降低到 O(logN)。为了防止插入删除时间消耗，跳表在创建节点的时候，随机生成每个节点的层数。具体的做法是，跳表在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%），那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数。</p><p><strong>整数集合</strong></p><p>整数集合本质上是一块连续内存空间。</p><p>整数集合有一个升级规则，就是当将一个新元素加入到整数集合里面，如果新元素的类型（int32_t）比整数集合现有所有元素的类型（int16_t）都要长时，整数集合需要先进行升级，也就是按新元素的类型（int32_t）扩展 contents 数组的空间大小，然后才能将新元素加入到整数集合里，升级的过程中也要维持整数集合的有序性。</p><p><strong>quicklist</strong></p><p>其实 quicklist 就是双向链表 + 压缩列表组合，quicklist 就是一个链表，而链表中的每个元素又是一个压缩列表。quicklist 解决办法，通过控制每个链表节点中的压缩列表的大小或者元素个数，来规避连锁更新的问题。因为压缩列表元素越少或越小，连锁更新带来的影响就越小，从而提供了更好的访问性能。</p><p><strong>listpack</strong></p><p>listpack 没有压缩列表中记录前一个节点长度的字段了，listpack 只记录当前节点的长度，当向 listpack 加入一个新元素的时候，不会影响其他节点的长度字段的变化，从而避免了压缩列表的连锁更新问题。</p>',30),_={id:"为什么用跳表而不用平衡树",tabindex:"-1"},R=t("a",{class:"header-anchor",href:"#为什么用跳表而不用平衡树","aria-hidden":"true"},"#",-1),k=t("p",null,[t("strong",null,"从内存占用上来比较，跳表比平衡树更灵活一些"),s("：平衡树每个节点包含 2 个指针(分别指向左右子树)，而跳表每个节点包含的指针数目平均为 1/(1-p)，如果像 Redis里的实现一样，取 p=1/4，那么平均每个节点包含 1.33 个指针，比平衡树更有优势。")],-1),v=t("p",null,[t("strong",null,"在做范围查找的时候，跳表比平衡树操作要简单"),s("：在平衡树上，找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在跳表上进行范围查找就非常简单，只需要在找到小值之后，对第 1 层链表进行若干步的遍历就可以实现。")],-1),L=t("p",null,[t("strong",null,"从算法实现难度上来比较，跳表比平衡树要简单得多"),s("。平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而跳表的插入和删除只需要修改相邻节点的指针，操作简单又快速。")],-1);function N(f,H){const i=r("Badge");return n(),o("div",null,[t("h3",g,[d,s(" Redis数据类型？"),e(i,{text:"重点",type:"danger"})]),c,t("h3",u,[h,s(" Redis底层数据结构？"),e(i,{text:"重点",type:"danger"})]),S,t("h3",_,[R,s(" 为什么用跳表而不用平衡树？"),e(i,{text:"掌握",type:"tip"})]),k,v,L])}const m=l(a,[["render",N],["__file","data-structure.html.vue"]]);export{m as default};
