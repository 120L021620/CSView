import{_ as i,X as l,Y as s,Z as e,$ as o,a0 as t,H as a}from"./framework-edbf9e3c.js";const c={},_={id:"慢查询的原因",tabindex:"-1"},r=e("a",{class:"header-anchor",href:"#慢查询的原因","aria-hidden":"true"},"#",-1),d=e("figure",null,[e("img",{src:"https://img-blog.csdnimg.cn/d3ba35cf63b44096b3766372845cf4ac.png",alt:"在这里插入图片描述",tabindex:"0",loading:"lazy"}),e("figcaption",null,"在这里插入图片描述")],-1),g={id:"mysql磁盘i-o很高有什么优化的方法",tabindex:"-1"},h=e("a",{class:"header-anchor",href:"#mysql磁盘i-o很高有什么优化的方法","aria-hidden":"true"},"#",-1),p=e("p",null,[e("strong",null,"设置组提交的两个参数"),o("： binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count 参数，延迟 binlog 刷盘的时机，从而减少 binlog 的刷盘次数。")],-1),u=e("div",{class:"hint-container tip"},[e("p",{class:"hint-container-title"},"提示"),e("p",null,"这个方法是基于“额外的故意等待”来实现的，因此可能会增加语句的响应时间，但即使 MySQL 进程中途挂了，也没有丢失数据的风险，因为 binlog 早被写入到 page cache 了，只要系统没有宕机，缓存在 page cache 里的 binlog 就会被持久化到磁盘。")],-1),m=e("p",null,[e("strong",null,"将 sync_binlog 设置为大于 1 的值(比较常见是 100~1000)"),o("：表示每次提交事务都 write，但累积 N 个事务后才 fsync，相当于延迟了 binlog 刷盘的时机。但是这样做的风险是，主机掉电时会丢 N 个事务的 binlog 日志。")],-1),b=e("p",null,[e("strong",null,"将 innodb_flush_log_at_trx_commit 设置为 2"),o("：表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log 写到 redo log 文件，注意写入到redo log 文件并不意味着写入到了磁盘，因为操作系统的文件系统中有个 Page Cache，专门用来缓存文件数据的，所以写入 redo log文件意味着写入到了操作系统的文件缓存，然后交由操作系统控制持久化到磁盘的时机。但是这样做的风险是，主机掉电的时候会丢数据。")],-1);function f(y,x){const n=a("Badge");return l(),s("div",null,[e("h3",_,[r,o(" 慢查询的原因？"),t(n,{text:"重要",type:"danger"})]),d,e("h3",g,[h,o(" MySQL磁盘I/O很高有什么优化的方法？"),t(n,{text:"了解",type:"info"})]),p,u,m,b])}const N=i(c,[["render",f],["__file","optimize.html.vue"]]);export{N as default};
