import{_ as n,W as s,X as a,a1 as e}from"./framework-17a5d3b6.js";const l={},i=e(`<h3 id="c-11有什么新特性" tabindex="-1"><a class="header-anchor" href="#c-11有什么新特性" aria-hidden="true">#</a> C++ 11有什么新特性？</h3><ul><li>提供 long long 长整型，占8个字节</li><li>提供统一的初始化语法，使用花括号{}初始化变量</li><li>提供空指针 <code>nullptr</code> 代替 <code>NULL</code></li><li>提供 constexpr 修饰函数、结构体，由编译器检查变量值是否为常量表达式</li><li>提供 using 来进行别名声明</li><li>提供 auto 进行自动变量类型推断， decltype 从表达式类型推断要定义的变量类型</li><li>提供范围for语句，例如 <code>for(auto x: range)</code></li><li>提供 cbegin() 和 cend() 函数，返回const迭代器</li><li>除法规则，商一律向0取整</li><li>提供 initializer_list 模板类型，元素永远为常量值，无法修改</li><li>提供尾置返回类型</li><li>可以使用 =default 要求编译器生成构造函数</li><li>提供 lambda 表达式，<code>[capture] (parameters) -&gt; return value { body }</code></li><li>提供无序关联容器：unordered_set，unordered_multiset，unordered_map，unordered_multimap</li><li>提供 default、delete 关键字</li><li>提供右值引用</li><li>提供 final、override 关键字</li></ul><h3 id="c-中多态是怎么实现的" tabindex="-1"><a class="header-anchor" href="#c-中多态是怎么实现的" aria-hidden="true">#</a> C++中多态是怎么实现的？</h3><p>多态是面向对象的重要特性之一，是一种行为封装，不同对象对同一行为有不同状态。多态是以封装和继承为基础的，在C++中多态分为静态多态和动态多态，静态多态通过函数重载实现，动态多态通过虚函数实现。</p><p><strong>静态多态</strong>：编译器在编译期间完成的，编译器会根据实参类型来推断该调用哪个函数，如果有对应的函数，就调用，没有则在编译时报错。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>include<span class="token operator">&lt;</span>iostream<span class="token operator">&gt;</span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token comment">//1</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">char</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">char</span> a<span class="token punctuation">,</span><span class="token keyword">char</span> b<span class="token punctuation">)</span><span class="token comment">//2</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">666</span><span class="token punctuation">,</span><span class="token number">888</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment">//1</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token char">&#39;1&#39;</span><span class="token punctuation">,</span><span class="token char">&#39;2&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//2</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>动态多态</strong>：动态多态是利用虚函数实现运行时的多态，即在系统编译的时候并不知道程序将要调用哪一个函数，只有在运行到这里的时候才能确定接下来会跳转到哪一个函数。实现动态多态需要虚函数，需要条件有</p><ul><li>在类中声明为虚函数</li><li>函数的函数名，返回值，函数参数个数，参数类型，全都与基类的所声明的虚函数相同(否则是函数重载的条件)</li><li>将子类对象的指针(或以引用形式)赋值给父类对象的指针(或引用)，再用该指向父类对象的指针(或引用)调用虚函数</li></ul><h3 id="重载和重写是如何实现的" tabindex="-1"><a class="header-anchor" href="#重载和重写是如何实现的" aria-hidden="true">#</a> 重载和重写是如何实现的？</h3><p>成员函数被重载的特征：</p><ul><li>相同的范围(在同一个类中)；</li><li>函数名字相同；</li><li>参数不同；</li><li>virtual关键字可有可无。</li></ul><p>重写是指派生类函数重写基类函数，是C++的多态的表现，特征是：</p><ul><li>不同的范围(分别位于派生类与基类)；</li><li>函数名字相同；</li><li>参数相同；</li><li>基类函数必须有virtual关键字。</li></ul><p><strong>重载实现</strong></p><ul><li><p>函数重载依靠函数的参数列表区分——也称为函数特征标(function signature)。如果两个函数的参数数目和类型相同，同时参数的排列顺序也相同，则它们的特征标相同，而变量名是无关紧要的。C++允许定义名称相同的函数，条件是它们的特征标不同。如果参数数目和/或参数类型不同，则特征标也不同。</p></li><li><p>使用被重载的函数时，需要在函数调用中使用正确的参数类型。根据函数名称和参数列表，编译器编译过程中选择对应的重载函数。C++编译器将执行名称修饰(name decoration)或名称矫正(name mangling)，它根据函数原型中指定的形参类型对每个函数名进行加密，该过程将对参数数目和类型进行编码。</p></li><li><p>匹配函数时，并不区分 const 和非 const 变量。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">dribble</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>bits<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// overloaded</span>
<span class="token keyword">void</span> <span class="token function">dribble</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>cbits<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// overloaded</span>
<span class="token keyword">void</span> <span class="token function">dabble</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span> bits<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// not overloaded </span>
<span class="token keyword">void</span> <span class="token function">drivel</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> bits<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// not overloaded </span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p><strong>重写实现</strong></p><ul><li>重写用虚函数来实现，在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。</li></ul><h3 id="c-中什么是菱形继承问题" tabindex="-1"><a class="header-anchor" href="#c-中什么是菱形继承问题" aria-hidden="true">#</a> C++ 中什么是菱形继承问题？</h3><p>如果有两个派生类继承了同一个基类，然后又有一个类同时继承了这两个派生类，这种继承称为菱形继承问题。</p><p>例如</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">/*
        如果有两个派生类继承了同一个基类，然后又有一个类同时继承了这两个派生类，这种继承称为菱形继承或者钻石型继承
                        A
                B                   C
                        D
                                Person
        Singer                                                     Waiter
                              SingingWaiter

        菱形继承带来的问题：
                1.歌手继承人的成员，服务员继承人的成员
                当唱歌的服务员调用成员的时候，会产生二义性。(加上作用域)

                2.唱歌的服务员继承自人的数据有两份，浪费内存
        菱形继承带来的问题的解决方案：虚继承
*/</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token keyword">int</span> m_Age<span class="token punctuation">;</span> <span class="token comment">// 年龄</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 歌手类，加上virtual是虚继承，Person类称为虚基类 </span>
<span class="token keyword">class</span> <span class="token class-name">Singer</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">Person</span></span>
<span class="token punctuation">{</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 服务员类</span>
<span class="token keyword">class</span> <span class="token class-name">Waiter</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token class-name">Person</span></span>
<span class="token punctuation">{</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 歌手+服务员类</span>
<span class="token keyword">class</span> <span class="token class-name">SingingWaiter</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Singer</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token class-name">Waiter</span></span>
<span class="token punctuation">{</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token comment">// 创建SingingWaiter对象</span>
        SingingWaiter sw<span class="token punctuation">;</span>

        <span class="token comment">// 问题1：访问同名的成员产生二义性</span>
        sw<span class="token punctuation">.</span>m_Age <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>
        <span class="token comment">/*sw.Singer::m_Age = 20;
        sw.Waiter::m_Age = 30;*/</span>

        <span class="token comment">// 问题2：继承了两份数据，浪费内存</span>
        cout <span class="token operator">&lt;&lt;</span> sw<span class="token punctuation">.</span>Singer<span class="token double-colon punctuation">::</span>m_Age <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> sw<span class="token punctuation">.</span>Waiter<span class="token double-colon punctuation">::</span>m_Age <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解决方法：使用虚继承方法。</p><h3 id="指针和引用的区别是什么" tabindex="-1"><a class="header-anchor" href="#指针和引用的区别是什么" aria-hidden="true">#</a> 指针和引用的区别是什么？</h3><p><strong>表层角度</strong></p><ul><li>引用必须被初始化，但是不分配存储空间。指针不声明时初始化，在初始化的时候需要分配存储空间。</li><li>引用初始化后不能被改变，指针可以改变所指的对象。</li><li>不存在指向空值的引用，但是存在指向空值的指针</li><li>引用没有顶层const</li><li>“sizeof引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小</li><li>引用是类型安全的，而指针不是 (引用比指针多了类型检查)</li></ul><p><strong>底层角度</strong></p><ul><li>引用和指针(代码如下) <ul><li>创建时产生的汇编代码一模一样</li><li>修改时产生的汇编也是一模一样</li></ul></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>val<span class="token punctuation">;</span> <span class="token comment">// lea eax,[a]  mov dword ptr[ebp-8],eax</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>ref <span class="token operator">=</span> val<span class="token punctuation">;</span>  <span class="token comment">// lea eax,[a]  mov dword ptr[ebp-oCh],eax</span>
<span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment">// mov eax, dword ptr[ebp-8]   mov dword[eax],14H</span>
ref <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>  <span class="token comment">// mov eax, dword ptr[ebp-0Ch]   mov dword[eax],14H</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>编译器维护了一张符号表，而且这个表贯串整个编译过程 <ul><li>使用元素本身访问：通过名字在符号表中找到地址，然后访问</li><li>使用指针访问：直接通过地址访问</li><li>引用在符号表中创建了一个名字不一样但地址一样的表项，故引用访问 -- 通过引用名字在符号表中找到地址，然后访问</li></ul></li><li>引用就是给同一块内存又起了一个名字</li></ul><h3 id="解释类模板和模板类的区别" tabindex="-1"><a class="header-anchor" href="#解释类模板和模板类的区别" aria-hidden="true">#</a> 解释类模板和模板类的区别？</h3><p><strong>类模板</strong>：主要描述的是模板，这个模板是类的模板。可以理解为一个通用的类，这个类中的数据成员，成员函数的形参类型以及成员函数的返回值类型不用具体的指定，这些类型都是虚拟的。在使用类模板进行对象定义的时候，才会根据对象的实际参数类型来替代类模板中的虚拟类型。</p><p><strong>模板类</strong>：主要描述的是类，这个类使用类模板进行声明。将类模板中的虚拟类型参数指定成一个具体的数据类型参数。</p><h3 id="c-右值引用与转移语义" tabindex="-1"><a class="header-anchor" href="#c-右值引用与转移语义" aria-hidden="true">#</a> C++ 右值引用与转移语义？</h3><p><strong>右值</strong>：右值是其地址无法通过解引用获得的值，因为它们是文字或本质上是临时的(例如，函数或显式构造函数返回的值)。</p><p><strong>右值引用</strong>：右值引用的标志是 &amp;&amp;，对右值的引用就是右值引用。</p><p><strong>转移语义</strong>：转移语义可以将资源(堆，系统对象等)从一个对象转移到另一个对象，这样能够减少不必要的临时对象的创建、拷贝以及销毁，能够大幅度提高 C++ 应用程序的性能。转移语义是和拷贝语义相对的，可以类比文件的剪切与拷贝，当我们将文件从一个目录拷贝到另一个目录时，速度比剪切慢很多。通过转移语义，临时对象中的资源能够转移其它的对象里。</p><p>在现有的 C++ 机制中，我们可以定义拷贝构造函数和赋值函数。要实现转移语义，需要定义转移构造函数，还可以定义转移赋值操作符。对于右值的拷贝和赋值会调用转移构造函数和转移赋值操作符。如果转移构造函数和转移拷贝操作符没有定义，那么就遵循现有的机制，拷贝构造函数和赋值操作符会被调用。</p><div class="hint-container tip"><p class="hint-container-title">补充</p><ol><li><p><strong>std::move作用以及应用场景？</strong></p><p>作用：返回传入参数的右值引用。 通过将对象传递给move函数，可以获得引用该对象的右值。</p><p>使用场景：标准库的许多组件都实现了移动语义，允许直接转移对象的资产和属性的所有权，而在参数为右值时无需复制它们。</p></li><li><p><strong>std::forward 作用以及使用场景？</strong></p><ul><li>右值穿参的问题：右值引用类型是独立于值的，一个右值引用参数作为函数的形参，在函数内部再转发该参数的时候它已经变成一个左值，并不是他原来的类型。</li><li>完美转发(Perfect Forwarding)，是指在函数模板中，完全依照模板的参数的类型(即保持参数的左值、右值特征)，将参数传递给函数模板中调用的另外一个函数。C++11中提供了这样的一个函数std::forward，它是为转发而生的，不管参数是T&amp;&amp;这种未定的引用还是明确的左值引用或者右值引用，它会按照参数本来的类型转发。</li><li>使用场景分析：std::forward 转发问题针对的是模板函数。</li><li>首先, forward常用于template函数中, 使用的时候必须要多带一个template参数T</li><li>其次, 明确只需要move的情况而用forward, 代码意图不清晰, 其他人看着理解起来比较费劲.</li><li>更技术上来说, 他们都可以被static_cast替代. 为什么不用static_cast呢? 也就是为了读着方便易懂.</li><li>函数模板 void G(A &amp;&amp;a)内部是无法知道形参对应的实参，到底是个普通变量，还是濒死的临时变量？只能原封不动的完美的转发std::forward给函数模板 void G(A &amp;&amp;a)调用的下一层函数。</li></ul></li><li><p><strong>move和forward的总结？</strong></p><ul><li>std::move无条件转换到右值。就其本身而言，它没有move任何东西。</li><li>std::forward只有在它的参数绑定到一个右值上的时候，它才转换它的参数到一个右值。</li><li>std::move和std::forward在运行期都没有做任何事情。</li></ul></li></ol><p>可以这么说，move属于强转，forward对于左值还是会转换成左值，对于右值转换成右值。一般在模板元编程里面，对于forward需求比较多，因为可以处理各种不同场景。而一般的代码里面，由于可以确认传入的是左值还是右值，所以一般直接就调用std::move了。</p></div><h3 id="使用协程的优点" tabindex="-1"><a class="header-anchor" href="#使用协程的优点" aria-hidden="true">#</a> 使用协程的优点？</h3><ul><li>协程拥有极高的执行效率，子程序切换不是线程切换而是由程序自身控制，没有线程切换开销，和多线程相比，线程数量越多，性能优势越明显。</li><li>不需要多线程锁机制，在协程中控制共享资源不加锁。</li><li>协程没有增加线程数量，在线程基础上分时复用运行多个协程，在用户态完成切换，切换代价很小。</li><li>协程只需要几十个字节保存相关状态信息，空间开销小。</li></ul>`,40),p=[i];function t(o,c){return s(),a("div",null,p)}const d=n(l,[["render",t],["__file","summary.html.vue"]]);export{d as default};
