import{_ as n,W as s,X as a,a1 as p}from"./framework-17a5d3b6.js";const e={},t=p(`<h3 id="内存区域" tabindex="-1"><a class="header-anchor" href="#内存区域" aria-hidden="true">#</a> 内存区域</h3><figure><img src="https://pic.imgdb.cn/item/63f8b8bdf144a010079d4c87.jpg" alt="image-20210909114511412" tabindex="0" loading="lazy"><figcaption>image-20210909114511412</figcaption></figure><p>HotSpot在JDK1.8之前方法区就是永久代，永久代就是方法区。</p><p>JDK1.8后删除了永久代，改为元空间，元空间在直接内存中。方法区就是元空间，元空间就是方法区。</p><p>创建一个线程，JVM就会为其分配一个私有内存空间，其中包括PC、虚拟机栈和本地方法栈</p><p><strong>PC</strong></p><p>用来指示下一个执行的字节码指令，基于这一点就能实现代码的控制流程</p><p>为了确保每个线程切换回来都能从上次的位置继续运行，PC必须是线程私有的，切换出去时需保存各自的PC</p><p><strong>虚拟机栈</strong></p><p>虚拟机栈中一个栈帧压入就对应一个方法的调用，栈帧弹出就对应方法返回。栈帧中包含：局部变量表、操作数栈、动态链接、方法出口信息。</p><p>局部变量表也就是常说的栈内存，用来存储基本类型和引用</p><p>HotSpot不支持动态扩展虚拟机栈，在创建线程时就确定了虚拟机栈的最大深度，如果申请不了这么多内存，就会抛出OOM错误，如果线程在运行时调用了很多方法，到达了栈的最大深度，就会抛出SOF错误</p><p><strong>本地方法栈</strong></p><p>和虚拟机栈相同，区别仅在于虚拟机栈中是java方法，本地方法栈中是native方法，但HotSpot中已经将二者合而为一了。</p><p><strong>堆</strong></p><p>JVM中最大的一块内存空间，所有对象实例和数组都在这里分配内存，所有线程共享堆内存。</p><p>JDK1.7开始默认开启了逃逸分析，如果一个对象只在一个线程中被引用了，则该对象可以直接在栈上分配内存空间。</p><p>堆也叫GC堆，是垃圾回收的主要区域。为了便于垃圾回收，JDK1.8之前将堆分为三个部分：</p><ol><li>新生代</li><li>老年代</li><li>永久代</li></ol><p>而1.8之后将永久代删除了，取而代之的是元空间，元空间则在直接内存中。</p><p>此外，新生代还细分为eden、from survivor（s0）和to survivor（s1）</p><p>当新对象实例产生时，年龄为0，首先被分配在eden里，在一次gc后，如果还存活，就被扔到survivor里，并且年龄+1，当年龄增加到一定程度后就被扔到老年代里。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。</p><p><strong>方法区</strong></p><p>存放被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><p>1.8之前是永久代，属于堆内存。1.8之后是元空间，属于直接内存。</p><p>永久代受JVM创建时分配的最大堆内存限制，而元空间则受系统内存限制，可以存储更多。</p><p><strong>常量池</strong></p><p>分为字符串常量池和运行时常量池</p><p>1.8之后字符串常量池在堆中，而运行时常量池在元空间</p><p><strong>直接内存</strong></p><p>在JVM进程的内存空间之外，属于系统内存。</p><p>JVM可通过native方法对其进行直接操作，而无需在使用时将其拷贝到JVM内存区。</p><h3 id="对象创建过程" tabindex="-1"><a class="header-anchor" href="#对象创建过程" aria-hidden="true">#</a> 对象创建过程</h3><figure><img src="https://pic.imgdb.cn/item/63f8b9aef144a010079ea749.jpg" alt="Java创建对象的过程" tabindex="0" loading="lazy"><figcaption>Java创建对象的过程</figcaption></figure><ol><li><p><strong>类加载检查：</strong></p><p>JVM遇到一条new指令时，先检查能不能在常量池中定位到该类的符号引用，并检查这个符号引用代表的类是否已被加载、解析和初始化。如果没有就要先进行类加载。类已被加载就通过检查。</p></li><li><p><strong>分配内存：</strong></p><p>类加载检查通过后JVM为新对象分配内存，对象所需的内存大小在类加载完成后就确定了，JVM会在堆中按照<strong>指针碰撞</strong>或<strong>空闲列表</strong>的方式为对象划分出一块空间，选择哪种方式会根据垃圾收集器的算法而定。此外，内存分配还要保证线程安全，JVM采用<strong>CAS+失败重试</strong>或<strong>TLAB</strong>的方式保证线程安全。</p><p>CAS+失败重试：乐观锁的一种实现，每次占用资源不加锁，而是不断尝试占用。</p><p>TLAB：线程创建时预先在堆中给线程分配一块内存，称为TLAB，专门用来存放该线程运行过程中创建的对象，而TLAB满了时，采用上述CAS在堆的其它内存中分配</p></li><li><p><strong>初始化零值：</strong></p><p>将对象的字段设为默认零值，不包括对象头</p></li><li><p><strong>设置对象头：</strong></p><p>在对象头中设置这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄、是否启用偏向锁等信息</p></li><li><p><strong>执行init方法：</strong></p><p>初始化对象，即按照程序员写的构造方法给对象进行初始化。</p></li></ol><h3 id="gc" tabindex="-1"><a class="header-anchor" href="#gc" aria-hidden="true">#</a> GC</h3><p><strong>内存分配与回收</strong></p><p>新对象优先被分配在eden里，年龄设置为0，经历第一次gc后如果还存活，就被扔到survivor中，并且年龄+1，随后每经历一次gc如果还存活就年龄+1，如果年龄超过了上限（默认15），就被扔到老年代中。通过-XX：MaxTenuringThreshold设置上限。</p><p>此外，JVM还有动态年龄判定机制：如果在survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到年龄超过上线。</p><p>如果是过大的对象，为了避免其来回复制，可以在创建时直接扔到老年代里。通过-XX：PretenureSizeThreshold设置，只支持Serial和ParNew。</p><figure><img src="https://i.loli.net/2021/09/12/MdbG2zIoR4FpKNr.png" alt="image-20210911183213177" tabindex="0" loading="lazy"><figcaption>image-20210911183213177</figcaption></figure><p>hotspot中gc分为两类：部分收集partial gc和全收集full gc。</p><p>部分收集又分minor gc、major gc和mixed gc</p><p>minor gc：只对新生代进行回收</p><p>major gc：只对老年代进行回收（有时也指代full gc）</p><p>mixed gc：对整个新生代和部分老年代进行回收</p><p>全收集full gc：对整个堆和方法区（hotspot中的元空间）进行回收</p><p><strong>判别对象、常量、类死亡的方法</strong></p><ul><li><strong>对象</strong></li></ul><ol><li><p><strong>引用计数法：</strong></p><p>对象中设置一个引用计数器，每当该对象被引用时，引用计数器就会+1，失去一个引用时就会-1。引用计数器为0时就代表已经死亡，不会再被引用了。这种判别方式有个缺点，如果两个对象互相引用，但又没有外界对它们的引用，则它们引用计数都为1，会一直存在，但没有意义。</p></li><li><p><strong>可达性分析法：</strong></p><p>设置一组对象为<strong>gc roots</strong>，如果一个对象没有能到达任何一个gc root的引用链，则判别这个对象死亡。一般一个线程启动后并列创建的一组对象会构成gc roots，gc roots内部引用的对象就是非gc root。<img src="https://i.loli.net/2021/09/12/Mncmzl8OVLdvBHE.png" alt="image-20210911220120397" loading="lazy"></p></li></ol><ul><li><strong>常量</strong></li></ul><p>没有被任何对象引用时就是废弃的</p><ul><li><strong>类</strong></li></ul><p>同时满足如下三点就是无用的类</p><ol><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 ClassLoader 已经被回收。</li><li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类 的方法。</li></ol><p><strong>引用类型都有哪些？</strong></p><ol><li><p><strong>强引用</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Object</span> strong <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>一个对象如果被引用，且最高级别是强引用，就不会被回收。</p></li><li><p><strong>软引用</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> soft <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>一个对象如果被引用，且最高级别是软引用，发生gc时内存足够就不会被回收，内存不够就会被回收。</p></li><li><p><strong>弱引用</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> weak <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>一个对象如果被引用，且最高级别是弱引用，发生gc时不管内存够不够都会被回收。</p></li><li><p><strong>虚引用</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">ReferenceQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> phantom <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>虚引用创建时必须搭配ReferenceQueue。</p><p>一个对象如果被引用，且最高级别是虚引用，就等于没有被引用，发生gc时不管内存够不够都会被回收。</p><p>虚引用看起来和弱引用没啥区别，只是必须搭配ReferenceQueue。</p><p>用虚引用的目的一般是跟踪对象被回收的活动。</p></li><li><p><strong>ReferenceQueue</strong></p><p>软引用、弱引用和虚引用在创建时都可以关联一个ReferenceQueue，其中虚引用必须关联，其余两个可选关联。</p><p>关联了ReferenceQueue的引用所引用的对象在被回收内存之前，这个引用会被JVM加入到关联的ReferenceQueue中。通过这样的机制，我们就能通过监听该队列，在对象内存被回收前进行一些自定义处理。</p></li></ol><p>在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。</p><p><strong>GC算法有哪些？</strong></p><ul><li><p><strong>标记-清除</strong> ：先标记上所有存活的对象，再一次性回收掉没被标记的，这是最基础的算法，后面的几个都是对其效率和空间碎片问题做了优化。 碎片问题会导致都是小空隙，装不下大对象，而如果将对象整理起来就会空出更大的空隙。</p></li><li><p><strong>复制</strong> ：将内存分为两块，只用其中一块，当用的这一块满了后，还是对其中存活的对象进行标记，然后将这些被标记的逐个复制到另一块内存，最后将剩余的死亡对象一次性回收，说白了就是两块内存来回倒。由于一次gc需要处理的总内存变小了，效率也就提升了。</p></li><li><p><strong>标记-整理</strong> ：和标记-清除一样，先标记存活对象，然后将它们堆到一端，最后回收掉末端以外的对象。</p></li><li><p><strong>分代收集</strong> ：新生代死亡对象比较多，一般用复制算法。老年代死亡对象比较少，一般用标记-清除或标记-整理算法</p></li></ul><h3 id="类加载流程" tabindex="-1"><a class="header-anchor" href="#类加载流程" aria-hidden="true">#</a> 类加载流程</h3><p><strong>加载</strong></p><p>将字节流读入JVM内存，在方法区存储为一个数据结构，同时创建一个对应的Class对象供程序访问。</p><p><strong>验证</strong></p><p>一共4步：</p><ol><li><p>文件格式验证</p><p>验证读进来的字节流是否符合Class标准格式。</p></li><li><p>元数据验证</p><p>格式对了之后，验证一下里边的数据合不合理。</p><p>比如：这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。</p></li><li><p>字节码验证</p><p>分析类的方法体（Class文件中的Code属性），确保方法在运行时不会危害虚拟机。</p></li><li><p>符号引用验证（发生在解析阶段）</p><p>检查常量池中引用的外部类是否存在，是否可以正常访问。</p></li></ol><p><strong>准备</strong></p><p>类变量（静态变量）分配内存并设置初值</p><p>其中如果是final修饰的，意味着在Class文件中，该字段的属性表中存在ConstantValue属性，此时初值设置为代码里写的。</p><p>如果不是，就设置为零值，等到初始化阶段再赋值。</p><p><strong>解析</strong></p><p>把符号引用（地址无关）转化为直接引用（地址相关）</p><p><strong>初始化</strong></p><p>执行clinit方法，这里要注意不是构造方法，而是执行静态语句，包括静态变量赋值和静态块</p>`,74),o=[t];function l(c,i){return s(),a("div",null,o)}const g=n(e,[["render",l],["__file","jvm.html.vue"]]);export{g as default};
