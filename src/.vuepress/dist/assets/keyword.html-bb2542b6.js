const e=JSON.parse('{"key":"v-7b7bcf90","path":"/golang/keyword.html","title":"","lang":"zh-CN","frontmatter":{"description":"make和new区别？ make：make能够分配并初始化类型所需的内存空间和结构，返回引用类型的本身；make具有使用范围的局限性，仅支持 channel、map、slice三种类型；make函数会对三种类型的内部数据结构（长度、容量等）赋值。 new：new能够分配类型所需的内存空间，返回指针引用（指向内存的指针）；new可被替代，能够通过字面值快...","head":[["meta",{"property":"og:url","content":"https://www.csguide.xyz/golang/keyword.html"}],["meta",{"property":"og:site_name","content":"CSView"}],["meta",{"property":"og:description","content":"make和new区别？ make：make能够分配并初始化类型所需的内存空间和结构，返回引用类型的本身；make具有使用范围的局限性，仅支持 channel、map、slice三种类型；make函数会对三种类型的内部数据结构（长度、容量等）赋值。 new：new能够分配类型所需的内存空间，返回指针引用（指向内存的指针）；new可被替代，能够通过字面值快..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[]}"]]},"headers":[{"level":3,"title":"make和new区别？","slug":"make和new区别","link":"#make和new区别","children":[]},{"level":3,"title":"slice的底层实现？","slug":"slice的底层实现","link":"#slice的底层实现","children":[]},{"level":3,"title":"slice和数组的区别？","slug":"slice和数组的区别","link":"#slice和数组的区别","children":[]},{"level":3,"title":"slice的扩容机制？","slug":"slice的扩容机制","link":"#slice的扩容机制","children":[]},{"level":3,"title":"slice是线程安全的吗？","slug":"slice是线程安全的吗","link":"#slice是线程安全的吗","children":[]},{"level":3,"title":"map的底层数据结构？","slug":"map的底层数据结构","link":"#map的底层数据结构","children":[]},{"level":3,"title":"bucket是如何工作的？","slug":"bucket是如何工作的","link":"#bucket是如何工作的","children":[]},{"level":3,"title":"map的查找过程？","slug":"map的查找过程","link":"#map的查找过程","children":[]},{"level":3,"title":"map的扩容过程？","slug":"map的扩容过程","link":"#map的扩容过程","children":[]},{"level":3,"title":"如何实现一个线程安全的map？","slug":"如何实现一个线程安全的map","link":"#如何实现一个线程安全的map","children":[]},{"level":3,"title":"channel的概念？","slug":"channel的概念","link":"#channel的概念","children":[]},{"level":3,"title":"channel有哪些状态？","slug":"channel有哪些状态","link":"#channel有哪些状态","children":[]},{"level":3,"title":"如何判断channel已经关闭？","slug":"如何判断channel已经关闭","link":"#如何判断channel已经关闭","children":[]},{"level":3,"title":"channel的底层实现原理？","slug":"channel的底层实现原理","link":"#channel的底层实现原理","children":[]},{"level":3,"title":"channel发送数据和接收数据的过程？","slug":"channel发送数据和接收数据的过程","link":"#channel发送数据和接收数据的过程","children":[]},{"level":3,"title":"channel是否线程安全的？","slug":"channel是否线程安全的","link":"#channel是否线程安全的","children":[]},{"level":3,"title":"channel如何实现线程安全的？","slug":"channel如何实现线程安全的","link":"#channel如何实现线程安全的","children":[]},{"level":3,"title":"channel的应用场景？","slug":"channel的应用场景","link":"#channel的应用场景","children":[]},{"level":3,"title":"defer的概述？","slug":"defer的概述","link":"#defer的概述","children":[]},{"level":3,"title":"defer的使用场景？","slug":"defer的使用场景","link":"#defer的使用场景","children":[]},{"level":3,"title":"defer的底层原理？","slug":"defer的底层原理","link":"#defer的底层原理","children":[]},{"level":3,"title":"defer函数和return的执行顺序？","slug":"defer函数和return的执行顺序","link":"#defer函数和return的执行顺序","children":[]},{"level":3,"title":"WaitGroup？","slug":"waitgroup","link":"#waitgroup","children":[]}],"git":{},"readingTime":{"minutes":18.55,"words":5566},"filePathRelative":"golang/keyword.md","autoDesc":true,"excerpt":""}');export{e as data};
