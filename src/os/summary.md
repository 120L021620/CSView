### mmap的使用场景以及原理？<Badge text="掌握" type="tip" />

**使用场景**

- 需要映射的文件是/dev/mem时，可以实现将物理地址映射到虚拟空间中
- 将一个普通文件映射到内存中，通常在需要对文件进行频繁读写时使用，使用内存读写代替I/O读写获得较高性能
- 用于进程间通信
- 用于进程间共享内存

**原理**

使用 mmap 系统调用可以将用户空间的虚拟内存地址与文件进行映射(绑定)，对映射后的虚拟内存地址进行读写操作就如同文件进行读写操作一样。mmap 映射的是文件的页缓存，而非磁盘中的文件本身。

mmap映射的页缓存同步到磁盘需要用户主动触发。同步mmap映射的内存到磁盘有4个时机：

- 调用 msync 函数主动进行数据同步(主动)
- 调用 munmap 函数对文件进行解除映射关系时(主动)
- 进程退出时(被动)
- 系统关机时(被动)
  ![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35a55af52d3042c79613feb41fc662d3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)



### select，poll，epoll的使用场景以及区别，epoll中水平触发以及边缘触发有什么不同？<Badge text="重点" type="danger" />

**使用场景和区别**

select，poll，epoll都是I/O多路复用机制，即能监视多个fd，某个fd就绪后通知程序进行相应读写操作。本质都是同步I/O，读写过程是阻塞的。

这3种方式的区别为

- select需要不断轮询数据检查文件描述符是否处于就绪状态，文件描述符数量限制为1024，且就绪后不会明确指出就绪的文件描述符，因此需要遍历确定。
- poll与select的区别在于poll的文件描述符没有限制。
- epoll采用回调机制，只会注册一个监听事件，数据变化时才通知，在文件描述符就绪后，明确指出就绪的文件描述符。
- 因此在使用场景上，在连接数少的情况下，select和poll的性能可能比epoll好，epoll机制需要函数回调，但在高并发情况下，使用epoll性能比select和poll好，因为轮询开销非常大。

**epoll水平触发和边缘触发**

当监听事件的文件描述符有发生可读写事件，但是这一次没有把数据读取完，水平触发下次调用时还会通知你，如果一直没有操作完，它会一直通知直到完成操作，而边缘触发只会通知一次。



### BIO、NIO有什么区别？怎么判断写文件时Buffer已经写满？<Badge text="掌握" type="tip" />

**区别**

BIO 同步阻塞式IO，数据的读取写入必须阻塞在一个线程内等待其完成。采用BIO通信模型的服务端，通常由一个独立的Acceptor线程负责监听客户端的连接。一般通过在 while(true) 循环中服务端会调用 accept() 方法等待接收客户端的连接的方式监听请求，请求一旦接收到一个连接请求，就可以建立通信套接字在这个通信套接字上进行读写操作，此时不能再接收其他客户端连接请求，只能等待同当前连接的客户端的操作执行完成。

NIO 同步非阻塞式IO，socket主要的读、写、注册和接收函数，在等待就绪阶段都是非阻塞的，真正的I/O操作是同步阻塞的。

区别在于：

- 在BIO模式下，调用read，如果发现没数据已经到达，就会Block住。
- 在NIO模式下，调用read，如果发现没数据已经到达，就会立刻返回-1, 并且errno被设为EAGAIN。在有些文档中写的是会返回EWOULDBLOCK。实际上，在Linux下EAGAIN和EWOULDBLOCK是一样的，即#define EWOULDBLOCK EAGAIN。
- NIO工作方式是轮询，不断的尝试有没有数据到达，在事件轮询时阻塞，其余是非阻塞的。

**判断写文件Buffer已满**

可以通过设置一个position变量来记录已经写入的大小，若等于buffer大小则认为buffer已经写满。



### 简述同步与异步的区别，阻塞与非阻塞的区别？<Badge text="了解" type="info" />

**同步**：执行一个操作之后，等待结果，然后才继续执行后续的操作。

**异步**：执行一个操作后，可以去执行其他的操作，然后等待对方通知再回来执行刚才没执行完的操作。

**阻塞**：进程给CPU传达一个任务之后，一直等待CPU处理完成，然后才执行后面的操作。

**非阻塞**：进程给CPU传达任务后，继续处理后续的操作，隔断时间再来询问之前的操作是否完成。

讨论同步/异步，阻塞/非阻塞区别需要注意上下文

- 阻塞/非阻塞核心区别就是看当前任务有没有被挂起。
- 在进程通信层面， 阻塞/非阻塞， 同步/异步基本是同义词， 但是需要注意区分讨论的对象是发送方还是接收方。发送方阻塞/非阻塞(同步/异步)和接收方的阻塞/非阻塞(同步/异步)是互不影响的。
- 在IO系统调用层面(IO system call)层面，非阻塞IO系统调用和异步IO系统调用存在着一定的差别， 它们都不会阻塞进程， 但是返回结果的方式和内容有所差别， 非阻塞IO返回结果可能不是完整结果也可能为空，异步IO返回结果完整，但是都属于非阻塞系统调用(non-blocing system call)。
- 阻塞和非阻塞是等待I/O的期间能不能做其他事情, 自己会不会被挂起, 是关注自己的状态，同步异步是是否需要主动询问, 描述的是行为方式(通信机制)。
- 非阻塞系统调用(non-blocking I/O system call 与 asynchronous I/O system call)的存在可以用来实现线程级别的I/O并发，与通过多进程实现的I/O并发相比可以减少内存消耗以及进程切换的开销。



### 自旋锁与互斥锁的使用场景？<Badge text="了解" type="info" />

**自旋锁**：CPU循环检测锁状态尝试进行锁的获取。

**互斥锁**：当线程或进程获取锁失败时释放CPU，由系统调度转到执行其他进程或线程。

**使用场景**：处于临界区时间很短的情况下，希望锁延迟时间短使用自旋锁，发生线程或进程调度，等待时间较长的场景使用互斥锁。



### CPU L1，L2，L3多级缓存的基本作用？<Badge text="掌握" type="tip" />

更新中



### 如何调试服务器内存占用过高的问题？<Badge text="了解" type="info" />

更新中