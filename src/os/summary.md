### mmap的使用场景以及原理？<Badge text="掌握" type="tip" />

**概念**

mmap用于把文件映射到内存空间中，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read、write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。

**原理**

**进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域**

1、进程在用户空间调用库函数mmap，原型：void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset)

2、在当前进程的虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址

3、为此虚拟区分配一个vm_area_struct结构，接着对这个结构的各个域进行了初始化

4、将新建的虚拟区结构(vm_area_struct)插入进程的虚拟地址区域链表或树中

**调用内核空间的系统调用函数mmap(不同于用户空间函数)，实现文件物理地址和进程虚拟地址的一一映射关系**

5、为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体(struct file)，每个文件结构体维护着和这个已打开文件相关各项信息。

6、通过该文件的文件结构体，链接到file_operations模块，调用内核函数mmap，其原型为：int mmap(struct file *filp, struct vm_area_struct *vma)，不同于用户空间库函数。

7、内核mmap函数通过虚拟文件系统inode模块定位到文件磁盘物理地址。

8、通过remap_pfn_range函数建立页表，即实现了文件地址和虚拟地址区域的映射关系。此时，这片虚拟地址并没有任何数据关联到主存中。

**进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存(主存)的拷贝**

9、进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表，发现这一段地址并不在物理页面上。因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。

10、缺页异常进行一系列判断，确定无非法操作后，内核发起请求调页过程。

11、调页过程先在交换缓存空间(swap cache)中寻找需要访问的内存页，如果没有则调用nopage函数把所缺的页从磁盘装入到主存中。

12、之后进程即可对这片主存进行读或者写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程。

注：修改过的脏页面并不会立即更新回文件中，而是有一段时间的延迟，可以调用msync()来强制同步, 这样所写的内容就能立即保存到文件里了。

**效率**

read()是系统调用，其中进行了数据拷贝，它首先将文件内容从硬盘拷贝到内核空间的一个缓冲区，然后再将这些数据拷贝到用户空间，在这个过程中，实际上完成了两次数据拷贝。

而mmap()也是系统调用，没有进行数据拷贝，真正的数据拷贝是在缺页中断处理时进行的，由于mmap()将文件直接映射到用户空间，所以中断处理函数根据这个映射关系，直接将文件从硬盘拷贝到用户空间，只进行了一次数据拷贝 。因此，内存映射的效率要比read/write效率高。

**场景**

- 需要映射的文件是/dev/mem时，可以实现将物理地址映射到虚拟空间中
- 将一个普通文件映射到内存中，通常在需要对文件进行频繁读写时使用，使用内存读写代替I/O读写获得较高性能
- 用于进程间通信
- 用于进程间共享内存



### select，poll，epoll的使用场景以及区别，epoll中水平触发以及边缘触发有什么不同？<Badge text="重点" type="danger" />

**I/O多路复用**

简而言之就是一个进程维护多个Socket连接。一个进程虽然任一时刻只能处理一个请求，但是处理每个请求的事件时耗时控制在 1 毫秒以内，这样 1 秒内就可以处理上千个请求，多个请求复用了一个进程，这就是多路复用。

select/poll/epoll 内核提供给用户态的多路复用系统调用，**进程可以通过一个系统调用函数从内核中获取多个事件**。

**非阻塞IO**

阻塞 I/O，是指进程发起调用后，会被挂起(阻塞)，直到收到数据再返回。如果调用一直不返回，进程就会一直被挂起。因此，当使用阻塞 I/O 时，需要使用**多线程**来处理多个文件描述符。多线程切换有一定的开销，因此引入非阻塞 I/O。非阻塞 I/O 不会将进程挂起，调用时会立即返回成功或错误，因此可以在**一个线程**里轮询多个文件描述符是否就绪。但是非阻塞 I/O 的缺点是：每次发起系统调用，只能检查**一个**文件描述符是否就绪。当文件描述符很多时，系统调用的成本很高。

**多路复用**

**通过一次系统调用，检查多个文件描述符的状态**。这是 I/O 多路复用的主要优点，相比于非阻塞 I/O，在文件描述符较多的场景下，避免了频繁的用户态和内核态的切换，减少了系统调用的开销。

进程可以通过 select、poll、epoll 发起 I/O 多路复用的系统调用，这些系统调用都是同步阻塞的：**如果传入的多个文件描述符中，有描述符就绪，则返回就绪的描述符；否则如果所有文件描述符都未就绪，就阻塞调用进程，直到某个描述符就绪，或者阻塞时长超过设置的 timeout 后，再返回**。I/O 多路复用内部使用**非阻塞 I/O** 检查每个描述符的就绪状态。

**select**

select 原理将已连接的 Socket 都放到一个**文件描述符集合**，然后调用 select 函数将文件描述符集合**拷贝**到内核里，让内核来检查是否有网络事件产生，检查是通过**遍历**文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合**拷贝**回用户态里，然后用户态还需要再通过**遍历**的方法找到可读或可写的 Socket，然后再对其处理。

select 这种方式，需要进行 **2 次「遍历」文件描述符集合**，一次是在内核态里，一个次是在用户态里 ，而且还会发生 **2 次「拷贝」文件描述符集合**，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。

select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的默认最大值为 `1024`，只能监听 0~1023 的文件描述符。

**poll**

poll 不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，没有文件描述符个数限制，当然还会受到系统文件描述符限制。

但是 poll 和 select 并没有太大的本质区别，**都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合**。

**epoll**

epoll 在内核里使用**红黑树来跟踪进程所有待检测的文件描述字**，把需要监控的 socket 通过加入内核中的红黑树里，红黑树是个高效的数据结构，增删改一般时间复杂度是 `O(logn)`。 epoll 因为在内核维护了红黑树，可以保存所有待检测的 socket ，所以只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。

epoll 使用**事件驱动**的机制，内核里**维护了一个链表来记录就绪事件**，当某个 socket 有事件发生时，通过**回调函数**内核会将其加入到这个就绪事件列表中，当用户调用 `epoll_wait()` 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。

**水平触发和边缘触发**

`select` 只支持水平触发，`epoll` 支持水平触发和边缘触发。

水平触发：当文件描述符就绪时，会触发通知，如果用户程序没有一次性把数据读/写完，下次还会发出可读/可写信号进行通知。

边缘触发：仅当描述符从未就绪变为就绪时，通知一次，之后不会再通知。

区别：边缘触发效率更高，**减少了事件被重复触发的次数**，函数不会返回大量用户程序可能不需要的文件描述符。

**边缘触发模式一般和非阻塞 I/O 搭配使用**，程序会一直执行 I/O 操作，直到系统调用(如 `read` 和 `write`)返回错误，错误。

select/poll 只有水平触发模式，epoll 默认的触发模式是水平触发，但是可以根据应用场景设置为边缘触发模式。

**对比**：

- `select`：调用开销大(需要复制集合)；集合大小有限制；需要遍历整个集合找到就绪的描述符
- `poll`：poll 采用数组的方式存储文件描述符，没有最大存储数量的限制，其他方面和 select 没有区别
- `epoll`：调用开销小(不需要复制)；集合大小无限制；采用回调机制，不需要遍历整个集合

`select`、`poll` 都是在用户态维护文件描述符集合，因此每次需要将完整集合传给内核；`epoll` 由操作系统在内核中维护文件描述符集合，因此只需要在创建的时候传入文件描述符。

**使用场景**

当连接数较多并且有很多的不活跃连接时，epoll 的效率比其它两者高很多。当连接数较少并且都十分活跃的情况下，由于 epoll 需要很多回调，因此性能可能低于其它两者。



### BIO、NIO有什么区别？怎么判断写文件时Buffer已经写满？<Badge text="掌握" type="tip" />

**区别**

BIO 同步阻塞式IO，数据的读取写入必须阻塞在一个线程内等待其完成。采用BIO通信模型的服务端，通常由一个独立的Acceptor线程负责监听客户端的连接。一般通过在 while(true) 循环中服务端会调用 accept() 方法等待接收客户端的连接的方式监听请求，请求一旦接收到一个连接请求，就可以建立通信套接字在这个通信套接字上进行读写操作，此时不能再接收其他客户端连接请求，只能等待同当前连接的客户端的操作执行完成。

NIO 同步非阻塞式IO，socket主要的读、写、注册和接收函数，在等待就绪阶段都是非阻塞的，真正的I/O操作是同步阻塞的。

区别在于：

- 在BIO模式下，调用read，如果发现没数据已经到达，就会Block住。
- 在NIO模式下，调用read，如果发现没数据已经到达，就会立刻返回-1, 并且errno被设为EAGAIN。在有些文档中写的是会返回EWOULDBLOCK。实际上，在Linux下EAGAIN和EWOULDBLOCK是一样的，即#define EWOULDBLOCK EAGAIN。
- NIO工作方式是轮询，不断的尝试有没有数据到达，在事件轮询时阻塞，其余是非阻塞的。

**判断写文件Buffer已满**

可以通过设置一个position变量来记录已经写入的大小，若等于buffer大小则认为buffer已经写满。



### 同步与异步的区别，阻塞与非阻塞的区别？<Badge text="了解" type="info" />

**同步**：执行一个操作之后，等待结果，然后才继续执行后续的操作。

**异步**：执行一个操作后，可以去执行其他的操作，然后等待对方通知再回来执行刚才没执行完的操作。

**阻塞**：进程给CPU传达一个任务之后，一直等待CPU处理完成，然后才执行后面的操作。

**非阻塞**：进程给CPU传达任务后，继续处理后续的操作，隔断时间再来询问之前的操作是否完成。

讨论同步/异步，阻塞/非阻塞区别需要注意上下文

- 阻塞/非阻塞核心区别就是看当前任务有没有被挂起。
- 在进程通信层面， 阻塞/非阻塞， 同步/异步基本是同义词， 但是需要注意区分讨论的对象是发送方还是接收方。发送方阻塞/非阻塞(同步/异步)和接收方的阻塞/非阻塞(同步/异步)是互不影响的。
- 在IO系统调用层面(IO system call)层面，非阻塞IO系统调用和异步IO系统调用存在着一定的差别， 它们都不会阻塞进程， 但是返回结果的方式和内容有所差别， 非阻塞IO返回结果可能不是完整结果也可能为空，异步IO返回结果完整，但是都属于非阻塞系统调用(non-blocing system call)。
- 阻塞和非阻塞是等待I/O的期间能不能做其他事情, 自己会不会被挂起, 是关注自己的状态，同步异步是是否需要主动询问, 描述的是行为方式(通信机制)。
- 非阻塞系统调用(non-blocking I/O system call 与 asynchronous I/O system call)的存在可以用来实现线程级别的I/O并发，与通过多进程实现的I/O并发相比可以减少内存消耗以及进程切换的开销。



### 自旋锁与互斥锁的使用场景？<Badge text="了解" type="info" />

**自旋锁**：CPU循环检测锁状态尝试进行锁的获取。

**互斥锁**：当线程或进程获取锁失败时释放CPU，由系统调度转到执行其他进程或线程。

**使用场景**：处于临界区时间很短的情况下，希望锁延迟时间短使用自旋锁，发生线程或进程调度，等待时间较长的场景使用互斥锁。



### CPU L1，L2，L3多级缓存的基本作用？<Badge text="掌握" type="tip" />

CPU包含三级缓存(L1，L2，L3)。

- L1最靠近CPU核心，L2其次，L3再次
- 运行速度方面：L1最快、L2次快、L3最慢
- 容量大小方面：L1最小、L2较大、L3最大

**一级缓存**

L1(1级)高速缓存是计算机系统中存在的最快的内存。就访问优先级而言，L1缓存具有CPU在完成特定任务时最可能需要的数据。L1缓存通常也分为两种方式，分为指令缓存和数据缓存。指令高速缓存处理有关CPU必须执行的操作的信息，而数据高速缓存则保留要在其上执行操作的数据。

**二级缓存**

L2(2级)缓存比L1缓存慢，但大小更大。它的大小通常在256KB到8MB之间，尽管更新，功能强大的CPU往往会超过此大小。L2高速缓存保存下一步可能由CPU访问的数据。在大多数现代CPU中，L1和L2高速缓存位于CPU内核本身，每个内核都有自己的高速缓存。

**三级缓存**

L3(3级)高速缓存是最大的高速缓存存储单元，也是最慢的一个。它的范围从4MB到50MB以上。现代CPU在CPU裸片上具有用于L3高速缓存的专用空间，并且占用了很大一部分空间。



### 如何调试服务器内存占用过高的问题？<Badge text="了解" type="info" />

(答案不唯一)

1. 先查看服务器剩余内存容量: `free -h`
2. 查看占用内存最大的10个进程: `ps -aux | sort -k4nr | head -n 10`
3. 查看内存占用最高的pid的线程：`top -Hp <pid>`
4. 使用分析工具对线程进行问题排查