### 常用的Linux命令？<Badge text="重点" type="danger" />

- find 查找文件或目录的路径
- pwd 显示当前所在路径
- ls 列出当前目录所有子目录与文件
- cd 切换工作目录
- man 查看帮助手册
- grep 查找文件或其他内容里符合条件的字符串
- chmod 控制用户对文件的权限的命令
- ps 列出系统中当前运行的进程
- kill 向执行中进程发出信号



### Linux页大小是多少？<Badge text="了解" type="info" />

默认为4KB



### Linux下如何查看CPU荷载，正在运行的线程，某个端口对应的进程？<Badge text="掌握" type="tip" />

使用`top`命令查看CPU使用情况，定位占用CPU过高的进程PID

使用`top -H -p <进程PID>` 定位对应进程中占用资源最高的线程id

两个方法查看占用端口进程

1. lsof -i:端口号
2. netstat -tunlp|grep 端口号



### Linux下如何排查CPU以及内存占用过多？<Badge text="了解" type="info" />

**排查CPU占用过高**

1. 使用```top```命令定位占用CPU过高的进程PID
2. 使用```top -H -p <进程PID>``` 定位进程中占用资源最高的线程id
   然后对线程进行排查

**排查内存占用过高**

1. 使用```cat /proc/meminfo```命令查看内存使用情况
2. 使用```free```命令查看内存使用情况
3. 使用```vmstat```命令显示系统资源实时和平均使用情况



### Linux如何查看实时的滚动日志？<Badge text="了解" type="info" />

更新中......





### Linux零拷贝的原理？<Badge text="重点" type="danger" />

传统I/O工作流如下图所示
![传统I/O工作流](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E4%BC%A0%E7%BB%9F%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93.png)

零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术。通过减少用户态与内核态上下文切换和减少内存拷贝次数实现，通常实现方式有3种：mmap+write、sendfile、sendfile+DMA scatter/gather

- **mmap+write**：
  mmap() 系统调用函数会直接把内核缓冲区里的数据「映射」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。包含2次系统调用，3次数据拷贝(2次DMA和1次CPU拷贝)
  1. 用户进程通过mmap方法向操作系统内核发起IO调用，**上下文从用户态切换为内核态**。
  2. CPU利用DMA控制器，把数据从硬盘中拷贝到内核缓冲区。
  3. **上下文从内核态切换回用户态**，mmap方法返回。
  4. 用户进程通过write方法向操作系统内核发起IO调用，**上下文从用户态切换为内核态**。
  5. CPU将内核缓冲区的数据拷贝到的socket缓冲区。
  6. CPU利用DMA控制器，把数据从socket缓冲区拷贝到网卡，**上下文从内核态切换回用户态**，write调用返回。
     ![](https://ask.qcloudimg.com/http-save/yehe-7197959/42e23f1db8479f4c6912f0593c8fea2d.png?imageView2/2/w/1620)  


- **sendfile**：
  在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用函数 sendfile()。它可以替代前面的 read() 和 write() 这两个系统调用，减少一次系统调用。包含1次系统调用，3次数据拷贝(2次DMA和1次CPU拷贝)
  1. 用户进程发起sendfile系统调用，上下文(切换1)从用户态转向内核态
  2. DMA控制器，把数据从硬盘中拷贝到内核缓冲区。
  3. CPU将读缓冲区中数据拷贝到socket缓冲区
  4. DMA控制器，异步把数据从socket缓冲区拷贝到网卡，
  5. 上下文(切换2)从内核态切换回用户态，sendfile调用返回。
     ![](https://ask.qcloudimg.com/http-save/yehe-7197959/314a45c2ce4f001c136a6f0941cafc39.png?imageView2/2/w/1620)

- **sendfile+DMA scatter/gather**：
  linux 2.4版本之后，对sendfile做了优化升级，引入SG-DMA技术，其实就是对DMA拷贝加入了scatter/gather操作，它可以直接从内核空间缓冲区中将数据读取到网卡。使用这个特点搞零拷贝，即还可以多省去一次CPU拷贝。包含1次系统调用，2次数据拷贝(2次DMA拷贝)。
  1. 用户进程发起sendfile系统调用，上下文(切换1)从用户态转向内核态
  2. DMA控制器，把数据从硬盘中拷贝到内核缓冲区。
  3. CPU把内核缓冲区中的文件描述符信息(包括内核缓冲区的内存地址和偏移量)发送到socket缓冲区
  4. DMA控制器根据文件描述符信息，直接把数据从内核缓冲区拷贝到网卡
  5. 上下文(切换2)从内核态切换回用户态，sendfile调用返回。
     ![](https://ask.qcloudimg.com/http-save/yehe-7197959/979075ba489c160e61dcb19426149620.png?imageView2/2/w/1620)





### Linux虚拟内存的页面置换算法？<Badge text="掌握" type="tip" />

- **最佳置换算法(OPT)**：对于每一个逻辑页面，计算它的下一次访问到现在的时间，选取最后访问的剔除，这是一种理想算法，通常用来计算最优解与其他算法比较

- **先进先出置换算法(FIFO)**：使用队列对页进行排序，选取最先进入的页踢出

- **最近最少未使用算法(LRU)**：选择一段时间内最久未使用的那个页面踢出

- **最不经常使用算法(LFU)**：统计页面的访问次数，选择一段时间内访问次数最少的页面踢出，这个算法需要统计页面使用次数，开销较大

- **时钟页面置换算法(CLOCK)**：系统中的所有页都放在一个循环列表(环形链表)中，时钟指针开始指向某个特定的页，所有页初始化为0，当必须进行页替换时，操作系统检查当前指向的页P的使用位是1还是0，如果是1，则意味着页面P最近被使用过，因此不适合被替换. 然后，P的使用位设置为0，时钟指针指下一页，该算法一直持续到找到一个使用位为0的页，使用位为0意味着这个页最近没有被使用过，最坏的情况下，如果所有的页都已经被使用了，那么就将所有页的使用位都设置为0





### Linux系统态与用户态，什么时候会进入系统态？<Badge text="掌握" type="tip" />

当一个任务(进程)执行系统调用而陷入内核代码中执行时，我们就称进程处于**内核态**。此时处理器处于特权级最高的(0级)内核代码。当进程处于内核态时，执行的内核代码会使用当前的内核栈。每个进程都有自己的内核栈。

当进程在执行用户自己的代码时，则称其处于**用户态**。即此时处理器在特权级最低的用户代码中运行。当正在执行用户程序而突然中断时，此时用户程序也可以象征性地处于进程的内核态。因为中断处理程序将使用当前进程的内核态。

在发生**系统调用**、**产生异常**或**外部设备产生中断**时，进程会从用户态进入内核态。





### Linux中虚拟内存和物理内存有什么区别？有什么优点？<Badge text="了解" type="info" />

**物理内存**就是系统硬件提供的内存大小，是真正的内存。相对于物理内存，Linux中的**虚拟内存**是为了满足物理内存的不足而提出的策略，它是利用磁盘空间虚拟出的一块逻辑内存。用作虚拟内存的磁盘空间被称为交换空间(又称 swap 空间)。

这种策略的优点在于作为物理内存的扩展，Linux 会在物理内存不足时，使用交换分区的虚拟内存，更详细地说，就是内核会将暂时不用的内存块信息写到交换空间，这样一来，物理内存得到了释放，这块内存就可以用于其他目的，当需要用到原始的内容时，这些信息会被重新从交换空间读入物理内存。



### Linux的I/O模型？<Badge text="掌握" type="tip" />

Linux有五种IO模型，**阻塞式IO、非阻塞式IO、IO复用、信号驱动式IO、异步IO**。

**阻塞式IO模型**

用户进程尝试读取数据，可是数据尚未达到(未准备好)此时内核也是处于等待状态，而用户进程就是阻塞状态。等到数据已经到达并来到了内核缓冲区，代表已经就绪；但是数据还只是在内核空间中，并没有被拷贝到用户空间中，所以这时候用户进程还是不能处理数据，继续阻塞。直到数据拷贝到用户空间中，用户进程才解除阻塞。
![](https://pic3.zhimg.com/80/v2-ca5e9b983f97bcfaa06f1bcaed3abbf2_1440w.webp)

**非阻塞式IO模型**：

在非阻塞IO中，recvfrom操作会立即返回结果而不是阻塞用户进程。

用户进程尝试读取数据，数据尚未达到(未准备好)此时内核是处于等待状态；但是由于是非阻塞IO，此时用户会返回异常，即用户进程并不会阻塞等待；用户进程拿到异常后，再次尝试读取，循环往复，直到数据就绪。等内存缓冲区内数据就绪后，数据还只是在内核空间中，并没有被拷贝到用户空间中，所以这时候用户进程还是不能处理数据，继续阻塞。直到数据拷贝到用户空间中，用户进程才解除阻塞，开始处理数据。
![](https://pic3.zhimg.com/80/v2-e1545bae41027e4ca795e22f00e7e8f2_1440w.webp)

**IO多路复用模型(异步阻塞IO)**

上述模型在单线程下只能依次处理单个IO事件，IO多路复用利用单个线程来同时监听多个FD，并在某个FD可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。监听方式有select、poll、epoll。

用户进程调用select，指定要监听的FD集合，然后内核监听FD对应的多个socket，任意一个或多个socket数据就绪则返回readable，此过程中用户进程阻塞。当有socket就绪后，用户进程找到就绪的socket依次调用recvfrom读取数据，内核将数据拷贝到用户空间后用户进程处理数据。
![](https://pic1.zhimg.com/80/v2-d4f222f3493d732ce5b4bafa72c6b210_1440w.webp)

**信号驱动IO**

信号驱动IO是与内核建立SIGIO的信号关联并设置回调，当内核有FD就绪时，会发出SIGIO信号通知用户，期间用户应用可以执行其它业务，无需阻塞等待。

用户进程调用sigaction，注册信号处理函数，随后内核返回成功，开始监听FD。用户进程不阻塞等待，可以执行其它业务，当内核数据就绪后，回调用户进程的SIGIO处理函数。然后用户进程收到SIGIO回调信号调用recvfrom，读取数据，内核将数据拷贝到用户空间后用户进程处理数据。
![](https://pic2.zhimg.com/80/v2-c4f9aa68cbf6ddf37d49de61d4d5b989_1440w.webp)

**异步IO**

异步IO的整个过程都是非阻塞的，用户进程调用完异步API后就可以去做其它事情，内核等待数据就绪并拷贝到用户空间后才会递交信号，通知用户进程。

用户进程调用aio_read，创建信号回调函数，内核等待数据就绪，然后用户进程无需阻塞，可以做任何事情。等内核数据就绪后，内核数据拷贝到用户缓冲区，拷贝完成，内核递交信号触发aio_read中的回调函数，用户进程处理数据。
![](https://img-blog.csdnimg.cn/img_convert/b5fdbf8016c87b614bf123b157e3da81.png#pic_center)



### traceroute命令的原理？<Badge text="了解" type="info" />

Traceroute程序的设计是利用ICMP及IP header的TTL(Time To Live)栏位(field)。首先，traceroute送出一个TTL是1的IP datagram(其实，每次送出的为3个40字节的包，包括源地址，目的地址和包发出的时间标签)到目的地，当路径上的第一个路由器(router)收到这个datagram时，它将TTL减1。此时，TTL变为0了，所以该路由器会将此datagram丢掉，并送回一个「ICMP time exceeded」消息(包括发IP包的源地址，IP包的所有内容及路由器的IP地址)，traceroute 收到这个消息后，便知道这个路由器存在于这个路径上，接着traceroute 再送出另一个TTL是2 的datagram，发现第2个路由器...，traceroute 每次将送出的datagram的TTL加1来发现另一个路由器，这个重复的动作一直持续到某个datagram抵达目的地。当datagram到达目的地后，该主机并不会送回ICMP time exceeded消息，因为它已是目的地了。Traceroute在送出UDP datagrams到目的地时，它所选择送达的port number 是一个一般应用程序都不会用的号码(30000 以上)，所以当此UDP datagram 到达目的地后该主机会送回一个「ICMP port unreachable」的消息，而当traceroute 收到这个消息时，便知道目的地已经到达了。