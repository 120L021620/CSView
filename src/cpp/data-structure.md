### new 与 malloc的区别？
  - malloc按字节开辟内存，new底层用malloc开辟内存，但还可提供初始化
  - malloc开辟失败返回空指针，new开辟失败返回bad_alloc异常
  - malloc是C的库函数，new是运算符重载
  - 对于数组和单个对象，malloc都是一样的，而对于new：new int()、new int\[20\]()

### vector的实现原理？

vector的底层实现是数组，占用连续的内存空间，vector是一个动态数组，大小随着元素的不断变多而变大，vector有两个关键属性：size和capacity。size表示当前vector存放了多少个元素，capacity表示vector当前总共能存多少个元素。在具体实现中

  - _Myfirst指向数组开始位置
  - _Mylast指向当前存放最后一个元素位置
  - _Myend指向数组末尾

![](https://img-blog.csdnimg.cn/2020080321564765.png)

vector的操作底层实现如下：

  - 当对空vector插入一个元素时首先会申请1个元素的空间并插入
  - 当内存空间用完时，在当前空间基础上乘以2申请新的内存空间，将原来内存空间数据拷贝到新内存，插入新元素并释放旧内存
  - 当在vector中间插入一个元素时（insert），把当前插入元素位置后面的元素向后移动，待插入元素插入相应位置
  - 当vector从末尾删除元素时，最后一个元素位置向前移一位，销毁最后一个元素
  - 从中间删除元素时，指定删除元素后所有元素向前移动一位，容器结束位置也向前移动一位


### vector 和 list 中，如果删除末尾的元素，其指针和迭代器如何变化？若删除的是中间的元素呢？

**迭代器和指针之间的区别**

迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，重载了指针的一些操作符，–>、++、–等。迭代器封装了指针，是一个“可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象，本质是封装了原生指针，是指针概念的一种提升，提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，–等操作。

对于vector，当在某个位置删除元素后：

  - 如果内存空间重新分配，则指向任何位置的迭代器、指针、引用都会失效；
  - 如果内存空间没有重新分配，则在删除位置之前的迭代器、指针、引用仍有效，删除位置之后的迭代器、指针、引用都失效；

对于list：

  - 任何位置删除元素，迭代器、指针、引用都不会失效，只有指向被删除元素的迭代器失效


### STL 中 vector 与 list 具体是怎么实现的？常见操作的时间复杂度是多少？

STL中vector实现为一个动态数组，它维护了一段连续的动态内存空间，然后有三个成员变量分别保存开始位置、当前已使用位置、申请的动态内存的最后一个位置的下一个位置，每当当前所申请的动态内存已经使用完时，它按照原有空间大小双倍重新申请，并把原来的元素都拷贝过去。

![](https://img-blog.csdnimg.cn/2020080321564765.png)

STL中list实现为一个链表，维护了一段非连续的存储结构，数据元素的逻辑顺序通过链表中的指针链接实现的。链表由一系列结点组成，第一部分是存储数据元素的数据域，第二部分是存储下一结点的指针域。

![](https://pic.wangt.cc/download/pic_router.php?path=https://img-blog.csdnimg.cn/f453cba8a3d0491289000016a857df76.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeGlhbyAgemhvdQ==,size_20,color_FFFFFF,t_70,g_se,x_16)

::: tip 常见操作时间复杂度
vector

  - 访问元素，时间复杂度为O(1)
  - 在末尾插入或者删除元素，时间复杂度也为O(1)
  - 在中间插入或者删除元素，时间复杂度为O(n)

list

  - 在开头末尾和中间插入或删除元素，时间复杂度为O(1)
  - 访问元素，时间复杂度为O(n)
:::


### const，static 关键字有什么区别？

**static修饰**

  - **局部变量** 将一个变量声明为函数的局部变量，那么这个局部变量在函数执行完成之后不会被释放，而是继续保留在内存中
  - **全局变量** 表示一个变量在当前文件的全局内可访问
  - **函数** 表示一个函数只能在当前文件中被访问
  - **类成员变量** 表示这个成员为全类所共有
  - **类成员函数** 表示这个函数为全类所共有，而且只能访问静态成员变量

**const修饰**

  - **常量**：定义时就初始化，以后不能更改。
  - **形参**：func(const int a){};该形参在函数里不能改变
  - **类成员函数**：该函数对成员变量只能进行只读操作

**static关键字的作用**

- 函数体内static变量的作用范围为该函数体，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；
- 在模块内的static全局变量和函数可以被模块内的函数访问，但不能被模块外其它函数访问；
- 在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；
- 在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。

**const关键字的作用**

- 阻止一个变量被改变
- 声明常量指针和指针常量
- const修饰形参，表明它是一个输入参数，在函数内部不能改变其值；
- 对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量；
- 对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为”左值”。


### STL 中的 map 的实现原理？

map是STL关联容器之一，以键值对形式进行数据存储。map内部自建一颗红黑树，红黑树具有对数据自动排序功能，所以map内部所有数据有序。红黑树插入删除查找等操作时间复杂度均为O(logn)。

另外，还有一种无序关联容器unordered_map，内部实现了一个哈希表,也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，查找的时间复杂度可达到O(1)，其元素<key,value>的排列顺序是无序的。


### 智能指针的特点？

智能指针其作用是管理一个指针，避免程序员申请的空间在函数结束时候忘记释放，造成内存泄漏这种情况发生。其是存储指向动态分配(堆)对象指针的类，确保离开指针所在的作用域时，自动销毁动态分配的对象，防止内存泄漏。智能指针实现的核心技术是引用计数，每使用一次，内部引用计数加1，每析构一次内部引用计数减1，减为0时，删除所指向的堆内存。智能指针包含：

  - **unique_ptr**：独占式拥有，同一时间内只有一个智能指针可以指向该对象。
  - **shared_ptr**：共享式拥有，多个智能指针可以指向同一个相同的对象，该对象和其他相关的资源会在最后一个引用被销毁时候释放。
  - **weak_ptr**：不控制对象生命周期的智能指针，他指向一个shared_ptr管理的对象。


### 智能指针和指针的区别？

智能指针和普通指针的区别在于智能指针实际上是对普通指针加了一层封装机制，区别是它负责自动释放所指的对象，这样的一层封装机制的目的是为了使得智能指针可以方便的管理一个对象的生命期。指针是一种数据类型，用于保存内存地址，而智能指针是类模板。

