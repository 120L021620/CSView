### C++ 11有什么新特性？

- 提供 long long 长整型，占8个字节
- 提供统一的初始化语法，使用花括号{}初始化变量
- 提供空指针 `nullptr` 代替 `NULL`
- 提供 constexpr 修饰函数、结构体，由编译器检查变量值是否为常量表达式
- 提供 using 来进行别名声明
- 提供 auto 进行自动变量类型推断， decltype 从表达式类型推断要定义的变量类型
- 提供范围for语句，例如 `for(auto x: range)`
- 提供 cbegin() 和 cend() 函数，返回const迭代器
- 除法规则，商一律向0取整
- 提供 initializer_list 模板类型，元素永远为常量值，无法修改
- 提供尾置返回类型
- 可以使用 =default 要求编译器生成构造函数
- 提供 lambda 表达式，`[capture] (parameters) -> return value { body }`
- 提供无序关联容器：unordered_set，unordered_multiset，unordered_map，unordered_multimap
- 提供 default、delete 关键字
- 提供右值引用
- 提供 final、override 关键字


### C++中多态是怎么实现的？

多态是面向对象的重要特性之一，是一种行为封装，不同对象对同一行为有不同状态。多态是以封装和继承为基础的，在C++中多态分为静态多态和动态多态，静态多态通过函数重载实现，动态多态通过虚函数实现。

**静态多态**：编译器在编译期间完成的，编译器会根据实参类型来推断该调用哪个函数，如果有对应的函数，就调用，没有则在编译时报错。

```cpp
include<iostream>
using namespace std;

int Add(int a,int b)//1
{
    return a+b;
}

char Add(char a,char b)//2
{
    return a+b;
}

int main()
{
    cout<<Add(666,888)<<endl;//1
    cout<<Add('1','2');//2
    return 0;
}
```

**动态多态**：动态多态是利用虚函数实现运行时的多态，即在系统编译的时候并不知道程序将要调用哪一个函数，只有在运行到这里的时候才能确定接下来会跳转到哪一个函数。实现动态多态需要虚函数，需要条件有

  - 在类中声明为虚函数
  - 函数的函数名，返回值，函数参数个数，参数类型，全都与基类的所声明的虚函数相同(否则是函数重载的条件)
  - 将子类对象的指针(或以引用形式)赋值给父类对象的指针(或引用)，再用该指向父类对象的指针(或引用)调用虚函数


### 重载和重写是如何实现的？

成员函数被重载的特征：

- 相同的范围(在同一个类中)；
- 函数名字相同；
- 参数不同；
- virtual关键字可有可无。

重写是指派生类函数重写基类函数，是C++的多态的表现，特征是：

- 不同的范围(分别位于派生类与基类)；
- 函数名字相同；
- 参数相同；
- 基类函数必须有virtual关键字。


**重载实现**

- 函数重载依靠函数的参数列表区分——也称为函数特征标(function signature)。如果两个函数的参数数目和类型相同，同时参数的排列顺序也相同，则它们的特征标相同，而变量名是无关紧要的。C++允许定义名称相同的函数，条件是它们的特征标不同。如果参数数目和/或参数类型不同，则特征标也不同。

- 使用被重载的函数时，需要在函数调用中使用正确的参数类型。根据函数名称和参数列表，编译器编译过程中选择对应的重载函数。C++编译器将执行名称修饰(name decoration)或名称矫正(name mangling)，它根据函数原型中指定的形参类型对每个函数名进行加密，该过程将对参数数目和类型进行编码。

- 匹配函数时，并不区分 const 和非 const 变量。

  ```cpp
  void dribble(char *bits); // overloaded
  void dribble (const char *cbits); // overloaded
  void dabble(char * bits);// not overloaded 
  void drivel(const char * bits);// not overloaded 
  ```

**重写实现**

- 重写用虚函数来实现，在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。

### C++ 中什么是菱形继承问题？

如果有两个派生类继承了同一个基类，然后又有一个类同时继承了这两个派生类，这种继承称为菱形继承问题。

例如

```cpp
/*
        如果有两个派生类继承了同一个基类，然后又有一个类同时继承了这两个派生类，这种继承称为菱形继承或者钻石型继承
                        A
                B                   C
                        D
                                Person
        Singer                                                     Waiter
                              SingingWaiter

        菱形继承带来的问题：
                1.歌手继承人的成员，服务员继承人的成员
                当唱歌的服务员调用成员的时候，会产生二义性。(加上作用域)

                2.唱歌的服务员继承自人的数据有两份，浪费内存
        菱形继承带来的问题的解决方案：虚继承
*/
class Person
{
public:
        int m_Age; // 年龄
};

// 歌手类，加上virtual是虚继承，Person类称为虚基类 
class Singer : virtual public Person
{
};

// 服务员类
class Waiter : public virtual Person
{
};

// 歌手+服务员类
class SingingWaiter : public Singer, public Waiter
{
};

int main()
{
        // 创建SingingWaiter对象
        SingingWaiter sw;

        // 问题1：访问同名的成员产生二义性
        sw.m_Age = 200;
        /*sw.Singer::m_Age = 20;
        sw.Waiter::m_Age = 30;*/

        // 问题2：继承了两份数据，浪费内存
        cout << sw.Singer::m_Age << endl;
        cout << sw.Waiter::m_Age << endl;

        return 0;
}
```

解决方法：使用虚继承方法。



### 指针和引用的区别是什么？

**表层角度**

- 引用必须被初始化，但是不分配存储空间。指针不声明时初始化，在初始化的时候需要分配存储空间。
- 引用初始化后不能被改变，指针可以改变所指的对象。
- 不存在指向空值的引用，但是存在指向空值的指针
- 引用没有顶层const
- “sizeof引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小
- 引用是类型安全的，而指针不是 (引用比指针多了类型检查)

**底层角度**

- 引用和指针(代码如下)
  - 创建时产生的汇编代码一模一样
  - 修改时产生的汇编也是一模一样

```cpp
int val = 10;
int *ptr = &val; // lea eax,[a]  mov dword ptr[ebp-8],eax
int &ref = val;  // lea eax,[a]  mov dword ptr[ebp-oCh],eax
*ptr = 20; // mov eax, dword ptr[ebp-8]   mov dword[eax],14H
ref = 20;  // mov eax, dword ptr[ebp-0Ch]   mov dword[eax],14H
```

- 编译器维护了一张符号表，而且这个表贯串整个编译过程
  - 使用元素本身访问：通过名字在符号表中找到地址，然后访问
  - 使用指针访问：直接通过地址访问
  - 引用在符号表中创建了一个名字不一样但地址一样的表项，故引用访问 -- 通过引用名字在符号表中找到地址，然后访问
- 引用就是给同一块内存又起了一个名字




### 解释类模板和模板类的区别？

**类模板**：主要描述的是模板，这个模板是类的模板。可以理解为一个通用的类，这个类中的数据成员，成员函数的形参类型以及成员函数的返回值类型不用具体的指定，这些类型都是虚拟的。在使用类模板进行对象定义的时候，才会根据对象的实际参数类型来替代类模板中的虚拟类型。

**模板类**：主要描述的是类，这个类使用类模板进行声明。将类模板中的虚拟类型参数指定成一个具体的数据类型参数。


### C++ 右值引用与转移语义？

**右值**：右值是其地址无法通过解引用获得的值，因为它们是文字或本质上是临时的(例如，函数或显式构造函数返回的值)。

**右值引用**：右值引用的标志是 &&，对右值的引用就是右值引用。

**转移语义**：转移语义可以将资源(堆，系统对象等)从一个对象转移到另一个对象，这样能够减少不必要的临时对象的创建、拷贝以及销毁，能够大幅度提高 C++ 应用程序的性能。转移语义是和拷贝语义相对的，可以类比文件的剪切与拷贝，当我们将文件从一个目录拷贝到另一个目录时，速度比剪切慢很多。通过转移语义，临时对象中的资源能够转移其它的对象里。

在现有的 C++ 机制中，我们可以定义拷贝构造函数和赋值函数。要实现转移语义，需要定义转移构造函数，还可以定义转移赋值操作符。对于右值的拷贝和赋值会调用转移构造函数和转移赋值操作符。如果转移构造函数和转移拷贝操作符没有定义，那么就遵循现有的机制，拷贝构造函数和赋值操作符会被调用。

::: tip 补充

1. **std::move作用以及应用场景？**

   作用：返回传入参数的右值引用。 通过将对象传递给move函数，可以获得引用该对象的右值。

   使用场景：标准库的许多组件都实现了移动语义，允许直接转移对象的资产和属性的所有权，而在参数为右值时无需复制它们。

2. **std::forward 作用以及使用场景？**

   - 右值穿参的问题：右值引用类型是独立于值的，一个右值引用参数作为函数的形参，在函数内部再转发该参数的时候它已经变成一个左值，并不是他原来的类型。
   - 完美转发(Perfect Forwarding)，是指在函数模板中，完全依照模板的参数的类型(即保持参数的左值、右值特征)，将参数传递给函数模板中调用的另外一个函数。C++11中提供了这样的一个函数std::forward，它是为转发而生的，不管参数是T&&这种未定的引用还是明确的左值引用或者右值引用，它会按照参数本来的类型转发。
   - 使用场景分析：std::forward 转发问题针对的是模板函数。
   - 首先, forward常用于template函数中, 使用的时候必须要多带一个template参数T
   - 其次, 明确只需要move的情况而用forward, 代码意图不清晰, 其他人看着理解起来比较费劲.
   - 更技术上来说, 他们都可以被static_cast替代. 为什么不用static_cast呢? 也就是为了读着方便易懂.
   - 函数模板 void G(A &&a)内部是无法知道形参对应的实参，到底是个普通变量，还是濒死的临时变量？只能原封不动的完美的转发std::forward给函数模板 void G(A &&a)调用的下一层函数。

3. **move和forward的总结？**

   - std::move无条件转换到右值。就其本身而言，它没有move任何东西。
   - std::forward只有在它的参数绑定到一个右值上的时候，它才转换它的参数到一个右值。
   - std::move和std::forward在运行期都没有做任何事情。

可以这么说，move属于强转，forward对于左值还是会转换成左值，对于右值转换成右值。一般在模板元编程里面，对于forward需求比较多，因为可以处理各种不同场景。而一般的代码里面，由于可以确认传入的是左值还是右值，所以一般直接就调用std::move了。

:::


### 使用协程的优点？

- 协程拥有极高的执行效率，子程序切换不是线程切换而是由程序自身控制，没有线程切换开销，和多线程相比，线程数量越多，性能优势越明显。
- 不需要多线程锁机制，在协程中控制共享资源不加锁。
- 协程没有增加线程数量，在线程基础上分时复用运行多个协程，在用户态完成切换，切换代价很小。
- 协程只需要几十个字节保存相关状态信息，空间开销小。