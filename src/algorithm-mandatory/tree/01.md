---
title: 树必刷题第一部分
author: 枫长
---

### [144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)

> 给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。

![](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)



遵循以下顺序：根节点 -> 左子树 -> 右子树。步骤如下：

1. 首先，初始化一个空列表 result，用于存储遍历过程中的节点值。
2. 确保根节点 root 不为 None，因为一个空树没有节点可以遍历。
3. 遍历过程可以通过递归或迭代的方式实现。我们将分别介绍这两种方法。

**解法一：递归方法**

1. 从根节点开始遍历。
2. 将当前节点值添加到 result 列表中。
3. 如果当前节点有左子节点，递归遍历左子树。
4. 如果当前节点有右子节点，递归遍历右子树。
5. 当遍历完成后，返回 result 列表。

**解法二：迭代方法**

1. 初始化一个空栈 stack，用于辅助遍历。
2. 将根节点压入 stack。
3. 当 stack 非空时，重复以下步骤： a. 弹出 stack 顶部的节点，并将其值添加到 result 列表中。 b. 如果该节点有右子节点，将右子节点压入 stack。 c. 如果该节点有左子节点，将左子节点压入 stack。
4. 当遍历完成后，返回 result 列表。

::: code-tabs

@tab cpp

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<TreeNode*> st;
        if(root != nullptr) {
            st.emplace_back(root);
        }
        vector<int> ans;
        while(!st.empty()) {
            TreeNode* cur = st.back();
            ans.emplace_back(cur->val);
            st.pop_back();
            if(cur->right != nullptr) {
                st.emplace_back(cur->right);
            }
            if(cur->left != nullptr) {
                st.emplace_back(cur->left);
            }
        }
        return ans;
    }
};
```

@tab java

@tab golang

:::

### [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

### [145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

### [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

### [662. 二叉树最大宽度](https://leetcode.cn/problems/maximum-width-of-binary-tree/)

### [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

### [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

### [110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)

### [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

### [572. 另一棵树的子树](https://leetcode.cn/problems/subtree-of-another-tree/)