---
title: 链表必刷题第三部分
author: 枫长
---

### [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

> 给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。

**解题思路**：
- 想做到时间复杂度O(n),空间复杂度O(1)，那么就是先快慢指针找到中点，然后反转后半部分链表，然后比较一遍。
- 如果链表个数是奇数的话，存在后边部分比前半部分多1的可能性，所以前后链表只要有一个遍历完了就退出比较。
- 链表操作是很容易发生bug的地方，建议多创指针，然后每一步写的详细些，该断开的地方断开，这样不容易出错。
::: code-tabs
@tab cpp
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverse(ListNode* begin) {
        ListNode* pre = nullptr, *next = nullptr;
        ListNode* cur = begin;
        while(cur != nullptr) {
            next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
    bool isPalindrome(ListNode* head) {
        if(head->next == nullptr) {
            return true;
        }
        ListNode* slow = head, *fast = head;
        ListNode* slowPre = nullptr;
        while(fast != nullptr && fast->next != nullptr) {
            fast = fast->next;
            if(fast->next != nullptr) {
                fast = fast->next;
            }
            slowPre = slow;
            slow = slow->next;
        }
        ListNode* end1 = slowPre;
        ListNode* begin1 = head;
        ListNode* begin2 = slow;
        slowPre->next = nullptr;
        ListNode* p1 = begin1;
        ListNode* p2 = reverse(begin2);
        while(p1 != nullptr && p2 != nullptr) {
            if(p1->val != p2->val) {
                return false;
            }
            p1 = p1->next;
            p2 = p2->next;
        }
        reverse(p2);
        end1->next = begin2;
        return true;
    }
};

```
@tab java
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while(fast != null) {
            slow = slow.next;
            fast = fast.next;
            if(fast == null) break;
            fast = fast.next;
        }
        ListNode newHead = reverse(slow);
        while(newHead != null) {
            if(head.val != newHead.val) return false;
            head = head.next;
            newHead = newHead.next;
        }
        return true;
    }

    private ListNode reverse(ListNode head) {
        if(head == null || head.next == null) return head;
        ListNode res = reverse(head.next);
        head.next.next = head;
        head.next = null;
        return res;
    }
}

```

@tab golang

```go
func isPalindrome(head *ListNode) bool {
	if head == nil || head.Next == nil {
		return true
	}
	slow, fast := head, head
	var prev *ListNode = nil
	for fast != nil && fast.Next != nil {
		prev = slow
		slow = slow.Next
		fast = fast.Next.Next
	}
	prev.Next = nil
	var head2 *ListNode = nil
	for slow != nil {
		tmp := slow.Next
		slow.Next = head2
		head2 = slow
		slow = tmp
	}
	for head != nil && head2 != nil {
		if head.Val != head2.Val {
			return false
		}
		head = head.Next
		head2 = head2.Next
	}
	return true
}
```
:::

### [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

> 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

**解题思路**

- 这道题也是一个考察**链表操作**的问题, 两两交换节点就是以3个为一组进行操作，当剩下节点不足三个时，直接返回。
- 链表操作中很多节点连接关系不注意就变化了，可以先把每个操作的节点存下来，这样不容易出错。
- 三个节点，cur，even，odd，按照cur，odd，even的顺序连就可以了，注意even先连上cur->next，或者你把cur->next保存下来让even最后连上也行。

::: code-tabs
@tab cpp

```cpp
    ListNode* swapPairs(ListNode* head) {
        if(head==nullptr || head->next==nullptr) return head;
        ListNode* org=new ListNode(0,head);
        ListNode* cur=org;
        while(cur->next!=nullptr && cur->next->next!=nullptr){
            ListNode* even=cur->next;
            ListNode* odd=cur->next->next;
            cur->next=odd;
            even->next=odd->next;
            odd->next=even;
            cur=even;
        }
        return org->next;
    }
```

@tab java

```java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/

class Solution {
    public Node copyRandomList(Node head) {
        if(head == null) return null;
        Node cur = head;
        while(cur != null) {
            Node tmp = cur.next;
            cur.next = new Node(cur.val);
            cur.next.next = tmp;
            cur = tmp;
        }
        cur = head;
        while(cur != null) {
            if(cur.random != null) {
                cur.next.random = cur.random.next;
            }
            cur = cur.next.next;
        }
        cur = head;
        Node nh = head.next;
        while(cur != null) {
            Node tmp = cur.next;
            if(cur.next == null) break;
            cur.next = cur.next.next;
            cur = tmp;
        }
        return nh;
    }
}

```

@tab golang

```go
func swapPairs(head *ListNode) *ListNode {
	dummy := &ListNode{}
	dummy.Next = head
	prev := dummy
	for head != nil && head.Next != nil {
		next := head.Next
		head.Next = next.Next
		next.Next = head
		prev.Next = next

		prev = head
		head = head.Next
	}
	return dummy.Next
}
```

:::

### [445. 两数相加 II](https://leetcode.cn/problems/add-two-numbers-ii/)

### [61. 旋转链表](https://leetcode.cn/problems/rotate-list/)

> 给你一个链表的头节点 `head` ，旋转链表，将链表每个节点向右移动 `k` 个位置。

**解题思路**

- 其实有个很简单的做法，你先遍历到链表结尾，记录链表长度len，再首尾相连成环形链表
- 然后再遍历len - k个到新链表的结尾，然后记录新链表的开头并断开
- 返回结果

::: code-tabs
@tab cpp
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if(!head || k == 0) return head;
        ListNode* end = head;
        int count = 0;
        while(end->next){
            end = end->next;
            count++;
        }
        end->next = head;

        int rotateTime = k % (count + 1);
        end = head;
        for(int i = 0;i < count - rotateTime; i++){
            end = end->next;
        }
        head = end->next;
        end->next = nullptr;
        return head;
    }
};
```
@tab java

```java

/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head == null || head.next == null) return false;
        ListNode slow = head;
        ListNode fast = head.next;
        while(slow != null && fast != null) {
            if(slow == fast) return true;
            slow = slow.next;
            fast = fast.next;
            if(fast != null) fast = fast.next;
        }
        return false;
    }
}
```
@tab golang
```go
func rotateRight(head *ListNode, k int) *ListNode {
    if k == 0 || head == nil || head.Next == nil {
        return head
    }
    n := 1
    iter := head
    for iter.Next != nil {
        iter = iter.Next
        n++
    }
    add := n - k%n
    if add == n {
        return head
    }
    iter.Next = head
    for add > 0 {
        iter = iter.Next
        add--
    }
    ret := iter.Next
    iter.Next = nil
    return ret
}
```

:::

### [328. 奇偶链表](https://leetcode.cn/problems/odd-even-linked-list/)

### [138. 复制带随机指针的链表](https://leetcode.cn/problems/copy-list-with-random-pointer/)

> 给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。
>
> 构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。
>
> 例如，如果原链表中有 X 和 Y 两个节点，其中 X.random --> Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random --> y 。
>
> 返回复制链表的头节点。
>
> 用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：
>
> val：一个表示 Node.val 的整数。
> random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。
> 你的代码只接受原链表的头节点 head 作为传入参数。

**解题思路**

- 这道题有两个方法：

- 方法1：需要额外创建一个**hash表**

- - 按next顺序遍历给出的链表，并为每个旧节点创建一个新节点，用hash表存映射

- - 之后在给每个新节点建立连接关系，旧节点->旧节点的映射关系拷贝到新节点上就是hash[旧节点]->hash[旧节点]，next和random的建立方式相同，遍历每个旧节点即可。

- 方法2：不需要用hash表来存映射关系，但是对链表操作要求比较高

- - 先给每个旧节点后面new一个新节点，这样旧节点->next = 对应新节点，旧节点->next->next = 原来的旧节点->next，以此来存映射关系。

- - 然后按照每个旧节点的映射关系给对应的新节点建立映射关系，最后再交替分开旧链表与新链表。
  

::: code-tabs
@tab cpp

```cpp
//方法一，hash表存映射
    Node* copyRandomList(Node* head) {
        unordered_map<Node*,Node*> hash;
        Node* cur=head;
        while(cur!=nullptr){
            Node* temp=new Node(cur->val);
            hash[cur]=temp;
            cur=cur->next;
        }
        cur=head;
        while(cur!=nullptr){
            hash[cur]->next=hash[cur->next];
            hash[cur]->random=hash[cur->random];
            cur=cur->next;
        }
        return hash[head];
    }
//方法二，新节点挂旧节点后面
    Node* copyRandomList(Node* head) {
        if(head==nullptr) return nullptr;
        Node* cur=head;
        while(cur!=nullptr){
            Node* temp=new Node(cur->val);
            Node* nextNode=cur->next;
            cur->next=temp;
            temp->next=nextNode;
            cur=temp->next;
        }
        cur=head;
        while(cur!=nullptr){
            if(cur->random!=nullptr) cur->next->random=cur->random->next;
            cur=cur->next->next;
        }
        cur=head;
        Node* newCur=head->next;
        Node* newhead=newCur;
        while(cur!=nullptr){
            cur->next=newCur->next;
            cur=cur->next;
            if(cur!=nullptr){
                newCur->next=cur->next;
                newCur=newCur->next;
            }
        }
        return newhead;
    }
```

@tab java

```java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/

class Solution {
    public Node copyRandomList(Node head) {
        if(head == null) return null;
        Node cur = head;
        while(cur != null) {
            Node tmp = cur.next;
            cur.next = new Node(cur.val);
            cur.next.next = tmp;
            cur = tmp;
        }
        cur = head;
        while(cur != null) {
            if(cur.random != null) {
                cur.next.random = cur.random.next;
            }
            cur = cur.next.next;
        }
        cur = head;
        Node nh = head.next;
        while(cur != null) {
            Node tmp = cur.next;
            if(cur.next == null) break;
            cur.next = cur.next.next;
            cur = tmp;
        }
        return nh;
    }
}


```

@tab golang

```go
var cachedNode map[*Node]*Node

func deepCopy(node *Node) *Node {
    if node == nil {
        return nil
    }
    if n, has := cachedNode[node]; has {
        return n
    }
    newNode := &Node{Val: node.Val}
    cachedNode[node] = newNode
    newNode.Next = deepCopy(node.Next)
    newNode.Random = deepCopy(node.Random)
    return newNode
}

func copyRandomList(head *Node) *Node {
    cachedNode = map[*Node]*Node{}
    return deepCopy(head)
}
```

::: 
