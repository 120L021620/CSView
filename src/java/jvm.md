---
title: Java
author: xmy
---

### 内存区域
![image-20210909114511412](https://i.loli.net/2021/09/12/txQ3RMvaociB5XZ.png)

HotSpot在JDK1.8之前方法区就是永久代，永久代就是方法区。

JDK1.8后删除了永久代，改为元空间，元空间在直接内存中。方法区就是元空间，元空间就是方法区。

创建一个线程，JVM就会为其分配一个私有内存空间，其中包括PC、虚拟机栈和本地方法栈

**PC**

用来指示下一个执行的字节码指令，基于这一点就能实现代码的控制流程

为了确保每个线程切换回来都能从上次的位置继续运行，PC必须是线程私有的，切换出去时需保存各自的PC

**虚拟机栈**

虚拟机栈中一个栈帧压入就对应一个方法的调用，栈帧弹出就对应方法返回。栈帧中包含：局部变量表、操作数栈、动态链接、方法出口信息。

局部变量表也就是常说的栈内存，用来存储基本类型和引用

HotSpot不支持动态扩展虚拟机栈，在创建线程时就确定了虚拟机栈的最大深度，如果申请不了这么多内存，就会抛出OOM错误，如果线程在运行时调用了很多方法，到达了栈的最大深度，就会抛出SOF错误

**本地方法栈**

和虚拟机栈相同，区别仅在于虚拟机栈中是java方法，本地方法栈中是native方法，但HotSpot中已经将二者合而为一了。

**堆**

JVM中最大的一块内存空间，所有对象实例和数组都在这里分配内存，所有线程共享堆内存。

JDK1.7开始默认开启了逃逸分析，如果一个对象只在一个线程中被引用了，则该对象可以直接在栈上分配内存空间。

堆也叫GC堆，是垃圾回收的主要区域。为了便于垃圾回收，JDK1.8之前将堆分为三个部分：

1. 新生代
2. 老年代
3. 永久代

而1.8之后将永久代删除了，取而代之的是元空间，元空间则在直接内存中。

此外，新生代还细分为eden、from survivor（s0）和to survivor（s1）

当新对象实例产生时，年龄为0，首先被分配在eden里，在一次gc后，如果还存活，就被扔到survivor里，并且年龄+1，当年龄增加到一定程度后就被扔到老年代里。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold  来设置。

**方法区**

存放被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

1.8之前是永久代，属于堆内存。1.8之后是元空间，属于直接内存。

永久代受JVM创建时分配的最大堆内存限制，而元空间则受系统内存限制，可以存储更多。

**常量池**

分为字符串常量池和运行时常量池

1.8之后字符串常量池在堆中，而运行时常量池在元空间

**直接内存**

在JVM进程的内存空间之外，属于系统内存。

JVM可通过native方法对其进行直接操作，而无需在使用时将其拷贝到JVM内存区。

### 对象创建过程
![Java创建对象的过程](https://i.loli.net/2021/09/12/y5mBCNQVfuAYWRh.png)

1. **类加载检查：**

   JVM遇到一条new指令时，先检查能不能在常量池中定位到该类的符号引用，并检查这个符号引用代表的类是否已被加载、解析和初始化。如果没有就要先进行类加载。类已被加载就通过检查。

2. **分配内存：**

   类加载检查通过后JVM为新对象分配内存，对象所需的内存大小在类加载完成后就确定了，JVM会在堆中按照**指针碰撞**或**空闲列表**的方式为对象划分出一块空间，选择哪种方式会根据垃圾收集器的算法而定。此外，内存分配还要保证线程安全，JVM采用**CAS+失败重试**或**TLAB**的方式保证线程安全。

   CAS+失败重试：乐观锁的一种实现，每次占用资源不加锁，而是不断尝试占用。

   TLAB：线程创建时预先在堆中给线程分配一块内存，称为TLAB，专门用来存放该线程运行过程中创建的对象，而TLAB满了时，采用上述CAS在堆的其它内存中分配

3. **初始化零值：**

   将对象的字段设为默认零值，不包括对象头

4. **设置对象头：**

   在对象头中设置这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄、是否启用偏向锁等信息

5. **执行init方法：**

   初始化对象，即按照程序员写的构造方法给对象进行初始化。
### GC


### 类加载